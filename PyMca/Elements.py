#/*##########################################################################
# Copyright (C) 2004-2006 European Synchrotron Radiation Facility
#
# This file is part of the PyMCA X-ray Fluorescence Toolkit developed at
# the ESRF by the Beamline Instrumentation Software Support (BLISS) group.
#
# This toolkit is free software; you can redistribute it and/or modify it 
# under the terms of the GNU General Public License as published by the Free
# Software Foundation; either version 2 of the License, or (at your option) 
# any later version.
#
# PyMCA is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# PyMCA; if not, write to the Free Software Foundation, Inc., 59 Temple Place,
# Suite 330, Boston, MA 02111-1307, USA.
#
# PyMCA follows the dual licensing model of Trolltech's Qt and Riverbank's PyQt
# and cannot be used as a free plugin for a non-free program. 
#
# Please contact the ESRF industrial unit (industry@esrf.fr) if this license 
# is a problem to you.
#############################################################################*/
#
#   Symbol  Atomic Number   x y ( positions on table )
#       name,  mass, density 
#
__revision__ = "$Revision: 1.82 $"
import string
import Numeric
import imp
import os
import sys
import re
import weakref
import types
import ConfigDict
import CoherentScattering
import IncoherentScattering

ElementsInfo = [
   ["H",   1,    1,1,   "hydrogen",   1.00800,     1008.00   ],
   ["He",  2,   18,1,   "helium",     4.00300,     0.118500  ],
   ["Li",  3,    1,2,   "lithium",    6.94000,     534.000   ],
   ["Be",  4,    2,2,   "beryllium",  9.01200,     1848.00   ],
   ["B",   5,   13,2,   "boron",      10.8110,     2340.00   ],
   ["C",   6,   14,2,   "carbon",     12.0100,     1580.00   ],
   ["N",   7,   15,2,   "nitrogen",   14.0080,     1.25      ],
   ["O",   8,   16,2,   "oxygen",     16.0000,     1.429     ],
   ["F",   9,   17,2,   "fluorine",   19.0000,     1108.00   ],
   ["Ne",  10,  18,2,   "neon",       20.1830,     0.9       ],
   ["Na",  11,   1,3,   "sodium",     22.9970,     970.000   ],
   ["Mg",  12,   2,3,   "magnesium",  24.3200,     1740.00   ],
   ["Al",  13,  13,3,   "aluminium",  26.9700,     2720.00   ],
   ["Si",  14,  14,3,   "silicon",    28.0860,     2330.00   ],
   ["P",   15,  15,3,   "phosphorus", 30.9750,     1820.00   ],
   ["S",   16,  16,3,   "sulphur",    32.0660,     2000.00   ],
   ["Cl",  17,  17,3,   "chlorine",   35.4570,     1560.00   ],
   ["Ar",  18,  18,3,   "argon",      39.9440,     1.78400   ],
   ["K",   19,   1,4,   "potassium",  39.1020,     862.000   ],
   ["Ca",  20,   2,4,   "calcium",    40.0800,     1550.00   ],
   ["Sc",  21,   3,4,   "scandium",   44.9600,     2992.00   ],
   ["Ti",  22,   4,4,   "titanium",   47.9000,     4540.00   ],
   ["V",   23,   5,4,   "vanadium",   50.9420,     6110.00   ],
   ["Cr",  24,   6,4,   "chromium",   51.9960,     7190.00   ],
   ["Mn",  25,   7,4,   "manganese",  54.9400,     7420.00   ],
   ["Fe",  26,   8,4,   "iron",       55.8500,     7860.00   ],
   ["Co",  27,   9,4,   "cobalt",     58.9330,     8900.00   ],
   ["Ni",  28,  10,4,   "nickel",     58.6900,     8900.00   ],
   ["Cu",  29,  11,4,   "copper",     63.5400,     8940.00   ],
   ["Zn",  30,  12,4,   "zinc",       65.3800,     7140.00   ],
   ["Ga",  31,  13,4,   "gallium",    69.7200,     5903.00   ],
   ["Ge",  32,  14,4,   "germanium",  72.5900,     5323.00   ],
   ["As",  33,  15,4,   "arsenic",    74.9200,     5.73000   ],
   ["Se",  34,  16,4,   "selenium",   78.9600,     4790.00   ],
   ["Br",  35,  17,4,   "bromine",    79.9200,     3120.00   ],
   ["Kr",  36,  18,4,   "krypton",    83.8000,     3.74000   ],
   ["Rb",  37,   1,5,   "rubidium",   85.4800,     1532.00   ],
   ["Sr",  38,   2,5,   "strontium",  87.6200,     2540.00   ],
   ["Y",   39,   3,5,   "yttrium",    88.9050,     4405.00   ],
   ["Zr",  40,   4,5,   "zirconium",  91.2200,     6530.00   ],
   ["Nb",  41,   5,5,   "niobium",    92.9060,     8570.00   ],
   ["Mo",  42,   6,5,   "molybdenum", 95.9500,     10220.00  ],
   ["Tc",  43,   7,5,   "technetium", 99.0000,     11500.0   ],
   ["Ru",  44,   8,5,   "ruthenium",  101.0700,    12410.0   ],
   ["Rh",  45,   9,5,   "rhodium",    102.9100,    124400    ],
   ["Pd",  46,  10,5,   "palladium",  106.400,     12160.0   ],
   ["Ag",  47,  11,5,   "silver",     107.880,     10500.00  ],
   ["Cd",  48,  12,5,   "cadmium",    112.410,     8650.00   ],
   ["In",  49,  13,5,   "indium",     114.820,     7280.00   ],
   ["Sn",  50,  14,5,   "tin",        118.690,     5310.00   ],
   ["Sb",  51,  15,5,   "antimony",   121.760,     6691.00   ],
   ["Te",  52,  16,5,   "tellurium",  127.600,     6240.00   ],
   ["I",   53,  17,5,   "iodine",     126.910,     4940.00   ],
   ["Xe",  54,  18,5,   "xenon",      131.300,     5.90000   ],
   ["Cs",  55,   1,6,   "caesium",    132.910,     1873.00   ],
   ["Ba",  56,   2,6,   "barium",     137.360,     3500.00   ],
   ["La",  57,   3,6,   "lanthanum",  138.920,     6150.00   ],
   ["Ce",  58,   4,9,   "cerium",     140.130,     6670.00   ],
   ["Pr",  59,   5,9,   "praseodymium",140.920,    6769.00   ],
   ["Nd",  60,   6,9,   "neodymium",  144.270,     6960.00   ],
   ["Pm",  61,   7,9,   "promethium", 147.000,     6782.00   ],
   ["Sm",  62,   8,9,   "samarium",   150.350,     7536.00   ],
   ["Eu",  63,   9,9,   "europium",   152.000,     5259.00   ],
   ["Gd",  64,  10,9,   "gadolinium", 157.260,     7950.00   ],
   ["Tb",  65,  11,9,   "terbium",    158.930,     8272.00   ],
   ["Dy",  66,  12,9,   "dysprosium", 162.510,     8536.00   ],
   ["Ho",  67,  13,9,   "holmium",    164.940,     8803.00   ],
   ["Er",  68,  14,9,   "erbium",     167.270,     9051.00   ],
   ["Tm",  69,  15,9,   "thulium",    168.940,     9332.00   ],
   ["Yb",  70,  16,9,   "ytterbium",  173.040,     6977.00   ],
   ["Lu",  71,  17,9,   "lutetium",   174.990,     9842.00   ],
   ["Hf",  72,   4,6,   "hafnium",    178.500,     13300.0   ],
   ["Ta",  73,   5,6,   "tantalum",   180.950,     16600.0   ],
   ["W",   74,   6,6,   "tungsten",   183.920,     19300.0   ],
   ["Re",  75,   7,6,   "rhenium",    186.200,     21020.0   ],
   ["Os",  76,   8,6,   "osmium",     190.200,     22500.0   ],
   ["Ir",  77,   9,6,   "iridium",    192.200,     22420.0   ],
   ["Pt",  78,  10,6,   "platinum",   195.090,     21370.0   ],
   ["Au",  79,  11,6,   "gold",       197.200,     19370.0   ],
   ["Hg",  80,  12,6,   "mercury",    200.610,     13546.0   ],
   ["Tl",  81,  13,6,   "thallium",   204.390,     11860.0   ],
   ["Pb",  82,  14,6,   "lead",       207.210,     11340.0   ],
   ["Bi",  83,  15,6,   "bismuth",    209.000,     9800.00   ],
   ["Po",  84,  16,6,   "polonium",   209.000,     0         ],
   ["At",  85,  17,6,   "astatine",   210.000,     0         ],
   ["Rn",  86,  18,6,   "radon",      222.000,     9.73000   ],
   ["Fr",  87,   1,7,   "francium",   223.000,     0         ],
   ["Ra",  88,   2,7,   "radium",     226.000,     0         ],
   ["Ac",  89,   3,7,   "actinium",   227.000,     0         ],
   ["Th",  90,   4,10,  "thorium",    232.000,     11700.0   ],
   ["Pa",  91,   5,10,  "proactinium",231.03588,   0         ],
   ["U",   92,   6,10,  "uranium",    238.070,     19050.0   ],
   ["Np",  93,   7,10,  "neptunium",  237.000,     0         ],
   ["Pu",  94,   8,10,  "plutonium",  239.100,     19700.0   ],
   ["Am",  95,   9,10,  "americium",  243,         0         ],
   ["Cm",  96,  10,10,  "curium",     247,         0         ],
   ["Bk",  97,  11,10,  "berkelium",  247,         0         ],
   ["Cf",  98,  12,10,  "californium",251,         0         ],
   ["Es",  99,  13,10,  "einsteinium",252,         0         ],
   ["Fm",  100,  14,10, "fermium",    257,         0         ],
   ["Md",  101,  15,10, "mendelevium",258,         0         ],
   ["No",  102,  16,10, "nobelium",   259,         0         ],
   ["Lr",  103,  17,10, "lawrencium", 262,         0         ],
   ["Rf",  104,   4,7,  "rutherfordium",261,       0         ],
   ["Db",  105,   5,7,  "dubnium",    262,         0         ],
   ["Sg",  106,   6,7,  "seaborgium", 266,         0         ],
   ["Bh",  107,   7,7,  "bohrium",    264,         0         ],
   ["Hs",  108,   8,7,  "hassium",    269,         0         ],
   ["Mt",  109,   9,7,  "meitnerium", 268,         0         ],
]
ElementList= [ elt[0] for elt in ElementsInfo ]
ElementShells = ['K','L1','L2','L3',
                 'M1','M2','M3','M4','M5',
                 'N1','N2','N3','N4','N5','N6','N7',
                 'O1','O2','O3','O4','O5','O6','O7',
                 'P1','P2','P3','P4','P5']

#L Z    K  L1  L2  L3  M1  M2  M3  M4  M5  N1  N2  N3  N4  N5  N6  N7  O1  O2  O3  O4  O5  O6  O7  P1  P2  P3  P4  P5
ElementBinding=[[1,  0.01360,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[2,  0.02460,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[3,  0.05480,  0.00530,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[4,  0.11210,  0.00800,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[5,  0.18800,  0.01260,  0.00470,  0.00470,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[6,  0.28380,  0.01800,  0.00640,  0.00640,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[7,  0.40160,  0.02440,  0.00920,  0.00920,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[8,  0.53200,  0.02850,  0.00710,  0.00710,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[9,  0.68540,  0.03400,  0.00860,  0.00860,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[10,  0.87010,  0.04850,  0.02170,  0.02160,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[11,  1.07210,  0.06330,  0.03110,  0.03110,  0.00070,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[12,  1.30500,  0.08940,  0.05140,  0.05140,  0.00210,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[13,  1.55960,  0.11770,  0.07320,  0.07270,  0.00070,  0.00550,  0.00550,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[14,  1.83890,  0.14870,  0.09950,  0.09890,  0.00760,  0.00300,  0.00300,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[15,  2.14550,  0.18930,  0.13620,  0.13530,  0.01620,  0.00990,  0.00990,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[16,  2.47200,  0.22920,  0.16540,  0.16420,  0.01580,  0.00800,  0.00800,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[17,  2.82240,  0.27020,  0.20160,  0.20000,  0.01750,  0.00680,  0.00680,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[18,  3.20600,  0.32630,  0.25070,  0.24860,  0.02920,  0.01590,  0.01580,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[19,  3.60740,  0.37710,  0.29630,  0.29360,  0.03390,  0.01780,  0.01780,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[20,  4.03810,  0.43780,  0.35000,  0.34640,  0.04370,  0.02540,  0.02540,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[21,  4.49280,  0.50040,  0.40670,  0.40220,  0.05380,  0.03230,  0.03230,  0.00660,  0.00660,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[22,  4.96640,  0.56370,  0.46150,  0.45550,  0.06030,  0.03460,  0.03460,  0.00370,  0.00370,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[23,  5.46510,  0.62820,  0.52050,  0.51290,  0.06650,  0.03780,  0.03780,  0.00220,  0.00220,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[24,  5.98920,  0.69460,  0.58370,  0.57450,  0.07410,  0.04250,  0.04250,  0.00230,  0.00230,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[25,  6.53900,  0.76900,  0.65140,  0.64030,  0.08390,  0.04860,  0.04860,  0.00330,  0.00330,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[26,  7.11200,  0.84610,  0.72110,  0.70810,  0.09290,  0.05400,  0.05400,  0.00360,  0.00360,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[27,  7.70890,  0.92560,  0.79360,  0.77860,  0.10070,  0.05950,  0.05950,  0.00290,  0.00290,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[28,  8.33280,  1.00810,  0.87190,  0.85470,  0.11180,  0.06810,  0.06810,  0.00360,  0.00360,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[29,  8.97890,  1.09610,  0.95100,  0.93110,  0.11980,  0.07360,  0.07360,  0.00160,  0.00160,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[30,  9.65860,  1.19360,  1.04280,  1.01970,  0.13590,  0.08660,  0.08660,  0.00810,  0.00810,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[31,  10.36710,  1.29770,  1.14230,  1.11540,  0.15810,  0.10680,  0.10290,  0.01740,  0.01740,  0.00150,  0.00080,  0.00080,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[32,  11.10310,  1.41430,  1.24780,  1.21670,  0.18000,  0.12790,  0.12080,  0.02870,  0.02870,  0.00500,  0.00230,  0.00230,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[33,  11.86670,  1.52650,  1.35860,  1.32310,  0.20350,  0.14640,  0.14050,  0.04120,  0.04120,  0.00850,  0.00250,  0.00250,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[34,  12.65780,  1.65390,  1.47620,  1.43580,  0.23150,  0.16820,  0.16190,  0.05670,  0.05670,  0.01200,  0.00560,  0.00560,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[35,  13.47370,  1.78200,  1.59600,  1.54990,  0.25650,  0.18930,  0.18150,  0.07010,  0.06900,  0.02730,  0.00520,  0.00460,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[36,  14.32560,  1.92100,  1.72720,  1.67490,  0.29210,  0.22180,  0.21450,  0.09500,  0.09380,  0.02750,  0.01470,  0.01400,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[37,  15.19970,  2.06510,  1.86390,  1.80440,  0.32210,  0.24740,  0.23850,  0.11180,  0.11030,  0.02930,  0.01480,  0.01400,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[38,  16.10460,  2.21630,  2.00680,  1.93960,  0.35750,  0.27980,  0.26910,  0.13500,  0.13310,  0.03770,  0.01990,  0.01990,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[39,  17.03840,  2.37250,  2.15550,  2.08000,  0.39360,  0.31240,  0.30030,  0.15960,  0.15740,  0.04540,  0.02560,  0.02560,  0.00240,  0.00240,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[40,  17.99760,  2.53160,  2.30670,  2.22230,  0.43030,  0.34420,  0.33050,  0.18240,  0.18000,  0.05130,  0.02870,  0.02870,  0.00300,  0.00300,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[41,  18.98560,  2.69770,  2.46470,  2.37050,  0.46840,  0.37840,  0.36300,  0.20740,  0.20460,  0.05810,  0.03390,  0.03390,  0.00320,  0.00320,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[42,  19.99950,  2.86550,  2.62510,  2.52020,  0.50460,  0.40970,  0.39230,  0.23030,  0.22700,  0.06180,  0.03480,  0.03480,  0.00180,  0.00180,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[43,  21.04400,  3.04250,  2.79320,  2.67690,  0.54400,  0.44490,  0.42500,  0.25640,  0.25290,  0.06800,  0.03890,  0.03890,  0.00200,  0.00200,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[44,  22.11720,  3.22400,  2.96690,  2.83790,  0.58500,  0.48280,  0.46060,  0.28360,  0.27940,  0.07490,  0.04310,  0.04310,  0.00200,  0.00200,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[45,  23.21990,  3.41190,  3.14610,  3.00380,  0.62710,  0.52100,  0.49620,  0.31170,  0.30700,  0.08100,  0.04790,  0.04790,  0.00250,  0.00250,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[46,  24.35030,  3.60430,  3.33030,  3.17330,  0.66990,  0.55910,  0.53150,  0.34000,  0.33470,  0.08640,  0.05110,  0.05110,  0.00150,  0.00150,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[47,  25.51400,  3.80580,  3.52370,  3.35110,  0.71750,  0.60240,  0.57140,  0.37280,  0.36670,  0.09520,  0.06260,  0.05590,  0.00330,  0.00330,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[48,  26.71120,  4.01800,  3.72700,  3.53750,  0.77020,  0.65070,  0.61650,  0.41050,  0.40370,  0.10760,  0.06690,  0.06690,  0.00930,  0.00930,  0.00000,  0.00000,  0.00220,  0.00220,  0.00220,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[49,  27.93990,  4.23750,  3.93800,  3.73010,  0.82560,  0.70220,  0.66430,  0.45080,  0.44310,  0.12190,  0.07740,  0.07740,  0.01620,  0.01620,  0.00000,  0.00000,  0.00010,  0.00080,  0.00080,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[50,  29.20010,  4.46470,  4.15610,  3.92880,  0.88380,  0.75640,  0.71440,  0.49330,  0.48480,  0.13650,  0.08860,  0.08860,  0.02390,  0.02390,  0.00000,  0.00000,  0.00090,  0.00110,  0.00110,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[51,  30.49120,  4.69830,  4.38040,  4.13220,  0.94370,  0.81190,  0.76560,  0.53690,  0.52750,  0.15200,  0.09840,  0.09840,  0.03140,  0.03140,  0.00000,  0.00000,  0.00670,  0.00210,  0.00210,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[52,  31.81380,  4.93920,  4.61200,  4.34140,  1.00600,  0.86970,  0.81870,  0.58250,  0.57210,  0.16830,  0.11020,  0.11020,  0.03980,  0.03980,  0.00000,  0.00000,  0.01160,  0.00230,  0.00230,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[53,  33.16940,  5.18810,  4.85210,  4.55710,  1.07210,  0.93050,  0.87460,  0.63130,  0.61940,  0.18640,  0.12270,  0.12270,  0.04960,  0.04960,  0.00000,  0.00000,  0.01360,  0.00330,  0.00330,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[54,  34.56440,  5.45280,  5.10370,  4.78220,  1.14870,  1.00210,  0.94060,  0.68940,  0.67670,  0.21330,  0.14550,  0.14550,  0.06950,  0.06750,  0.00000,  0.00000,  0.02340,  0.01340,  0.01210,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[55,  35.98460,  5.71430,  5.35940,  5.01190,  1.21710,  1.06500,  0.99760,  0.73950,  0.72550,  0.23080,  0.17230,  0.16160,  0.07880,  0.07650,  0.00000,  0.00000,  0.02270,  0.01310,  0.01140,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[56,  37.44060,  5.98880,  5.62360,  5.24700,  1.29280,  1.13670,  1.06220,  0.79610,  0.78070,  0.25300,  0.19180,  0.17970,  0.09250,  0.08990,  0.00000,  0.00000,  0.02910,  0.01660,  0.01460,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[57,  38.92460,  6.26630,  5.89060,  5.48270,  1.36130,  1.20440,  1.12340,  0.84850,  0.83170,  0.27040,  0.20580,  0.19140,  0.09890,  0.09890,  0.00000,  0.00000,  0.03230,  0.01440,  0.01440,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[58,  40.44300,  6.54880,  6.16420,  5.72340,  1.43460,  1.27280,  1.18540,  0.90130,  0.88330,  0.28960,  0.22330,  0.20720,  0.11000,  0.11000,  0.00010,  0.00010,  0.03780,  0.01980,  0.01980,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[59,  41.99060,  6.83480,  6.44040,  5.96430,  1.51100,  1.33740,  1.24220,  0.95110,  0.93100,  0.30450,  0.23630,  0.21760,  0.11320,  0.11320,  0.00200,  0.00200,  0.03740,  0.02230,  0.02230,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[60,  43.56890,  7.12600,  6.72150,  6.20790,  1.57530,  1.40280,  1.29740,  0.99990,  0.97770,  0.31520,  0.24330,  0.22460,  0.11750,  0.11750,  0.00150,  0.00150,  0.03750,  0.02110,  0.02110,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[61,  45.18400,  7.42790,  7.01280,  6.45930,  1.65000,  1.47140,  1.35690,  1.05150,  1.02690,  0.33100,  0.24200,  0.24200,  0.12040,  0.12040,  0.00400,  0.00400,  0.03800,  0.02200,  0.02200,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[62,  46.83420,  7.73680,  7.31180,  6.71620,  1.72280,  1.54070,  1.41980,  1.10600,  1.08020,  0.34570,  0.26560,  0.24740,  0.12900,  0.12900,  0.00550,  0.00550,  0.03740,  0.02130,  0.02130,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[63,  48.51900,  8.05200,  7.61710,  6.97690,  1.80000,  1.61390,  1.48060,  1.16060,  1.13090,  0.36020,  0.28390,  0.25660,  0.13320,  0.13320,  0.00000,  0.00000,  0.03180,  0.02200,  0.02200,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[64,  50.23910,  8.37560,  7.93030,  7.24280,  1.88080,  1.68830,  1.54400,  1.21720,  1.18520,  0.37580,  0.28850,  0.27090,  0.14050,  0.14050,  0.00010,  0.00010,  0.03610,  0.02030,  0.02030,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[65,  51.99570,  8.70800,  8.25160,  7.51400,  1.96750,  1.76770,  1.61130,  1.27500,  1.24120,  0.39790,  0.31020,  0.28500,  0.14700,  0.14700,  0.00260,  0.00260,  0.03900,  0.02540,  0.02540,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[66,  53.78850,  9.04580,  8.58060,  7.79010,  2.04680,  1.84180,  1.67560,  1.33250,  1.29490,  0.41630,  0.33180,  0.29290,  0.15420,  0.15420,  0.00420,  0.00420,  0.06290,  0.02630,  0.02630,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[67,  55.61770,  9.39420,  8.91780,  8.07110,  2.12830,  1.92280,  1.74120,  1.39150,  1.35140,  0.43570,  0.34350,  0.30660,  0.16100,  0.16100,  0.00370,  0.00370,  0.05120,  0.02030,  0.02030,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[68,  57.48550,  9.75130,  9.26430,  8.35790,  2.20650,  2.00580,  1.81180,  1.45330,  1.40930,  0.44910,  0.36620,  0.32000,  0.17670,  0.16760,  0.00430,  0.00430,  0.05980,  0.02940,  0.02940,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[69,  59.38960,  10.11570,  9.61690,  8.64800,  2.30680,  2.08980,  1.88450,  1.51460,  1.46770,  0.47170,  0.38590,  0.33660,  0.17960,  0.17960,  0.00530,  0.00530,  0.05320,  0.03230,  0.03230,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[70,  61.33230,  10.48640,  9.97820,  8.94360,  2.39810,  2.17300,  1.94980,  1.57630,  1.52780,  0.48720,  0.39670,  0.34350,  0.19810,  0.18490,  0.00630,  0.00630,  0.05410,  0.02340,  0.02340,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[71,  63.31380,  10.87040,  10.34860,  9.24410,  2.49120,  2.26350,  2.02360,  1.63940,  1.58850,  0.50620,  0.41010,  0.35930,  0.20480,  0.19500,  0.00690,  0.00690,  0.05680,  0.02800,  0.02800,  0.00460,  0.00460,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[72,  65.35080,  11.27070,  10.73940,  9.56070,  2.60090,  2.36540,  2.10760,  1.71640,  1.66170,  0.53810,  0.43700,  0.38040,  0.22380,  0.21370,  0.01710,  0.01710,  0.06490,  0.03810,  0.03060,  0.00660,  0.00660,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[73,  67.41640,  11.68150,  11.13610,  9.88110,  2.70800,  2.46870,  2.19400,  1.79320,  1.73510,  0.56550,  0.46480,  0.40450,  0.24130,  0.22930,  0.02750,  0.02560,  0.07110,  0.04490,  0.03640,  0.00570,  0.00570,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[74,  69.52500,  12.09980,  11.54400,  10.20680,  2.81960,  2.57490,  2.28100,  1.87160,  1.80920,  0.59500,  0.49160,  0.42530,  0.25880,  0.24540,  0.03790,  0.03580,  0.07710,  0.04680,  0.03560,  0.00610,  0.00610,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[75,  71.67640,  12.52670,  11.95870,  10.53530,  2.93170,  2.68160,  2.36730,  1.94890,  1.88290,  0.62500,  0.51790,  0.44440,  0.27370,  0.26020,  0.04810,  0.04570,  0.08280,  0.04560,  0.03460,  0.00350,  0.00350,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[76,  73.87080,  12.96800,  12.38500,  10.87090,  3.04850,  2.79220,  2.45720,  2.03080,  1.96010,  0.65430,  0.54650,  0.46820,  0.28940,  0.27280,  0.05380,  0.05100,  0.08370,  0.05800,  0.04540,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[77,  76.11100,  13.41850,  12.82410,  11.21520,  3.17370,  2.90870,  2.55070,  2.11610,  2.04040,  0.69010,  0.57710,  0.49430,  0.31140,  0.29490,  0.06400,  0.06100,  0.09520,  0.06300,  0.05050,  0.00380,  0.00380,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[78,  78.39480,  13.88050,  13.27260,  11.56380,  3.29760,  3.02700,  2.64530,  2.20150,  2.12110,  0.72400,  0.60760,  0.51910,  0.33070,  0.31380,  0.07450,  0.07110,  0.10170,  0.06530,  0.05100,  0.00210,  0.00210,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[79,  80.72490,  14.35280,  13.73360,  11.91870,  3.42490,  3.14780,  2.74300,  2.29110,  2.20570,  0.75880,  0.64370,  0.54540,  0.35200,  0.33390,  0.08780,  0.08410,  0.10780,  0.07170,  0.05870,  0.00250,  0.00250,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[80,  83.10230,  14.83930,  14.20870,  12.28390,  3.56160,  3.27850,  2.84710,  2.38490,  2.29490,  0.80300,  0.68100,  0.57690,  0.37850,  0.35930,  0.10400,  0.09990,  0.12030,  0.08400,  0.06500,  0.00980,  0.00780,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[81,  85.53040,  15.34670,  14.69790,  12.65750,  3.70410,  3.41570,  2.95660,  2.48510,  2.38930,  0.84550,  0.72130,  0.60900,  0.40660,  0.38620,  0.12310,  0.11880,  0.13630,  0.09960,  0.07300,  0.01530,  0.01310,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
[82,  88.00450,  15.86080,  15.20000,  13.03520,  3.85070,  3.55420,  3.06640,  2.58560,  2.48400,  0.89360,  0.76390,  0.64450,  0.43520,  0.41290,  0.14120,  0.13630,  0.14730,  0.10480,  0.08300,  0.02180,  0.01920,  0.00000,  0.00000,  0.00310,  0.00070,  0.00070,  0.00000,  0.00000],
[83,  90.52590,  16.38750,  15.71110,  13.41860,  3.99910,  3.69630,  3.17690,  2.68760,  2.57960,  0.93820,  0.80530,  0.67890,  0.46360,  0.44000,  0.16240,  0.15710,  0.15930,  0.11680,  0.09300,  0.02650,  0.02440,  0.00000,  0.00000,  0.00800,  0.00270,  0.00270,  0.00000,  0.00000],
[84,  93.10000,  16.92800,  16.23700,  13.81000,  4.15200,  3.84400,  3.29300,  2.79400,  2.68000,  0.98700,  0.85100,  0.71500,  0.49500,  0.46900,  0.18400,  0.17800,  0.17600,  0.13200,  0.10200,  0.03400,  0.03000,  0.00000,  0.00000,  0.00900,  0.00400,  0.00100,  0.00000,  0.00000],
[85,  95.72400,  17.48200,  16.77600,  14.20700,  4.31000,  3.99400,  3.40900,  2.90100,  2.78100,  1.03800,  0.89700,  0.75100,  0.52700,  0.49900,  0.20600,  0.19900,  0.19200,  0.14400,  0.11300,  0.04100,  0.03700,  0.00000,  0.00000,  0.01300,  0.00600,  0.00100,  0.00000,  0.00000],
[86,  98.39700,  18.04800,  17.32800,  14.61000,  4.47300,  4.15000,  3.52900,  3.01200,  2.88400,  1.09000,  0.94400,  0.79000,  0.55800,  0.53000,  0.22900,  0.22200,  0.20800,  0.15800,  0.12300,  0.04800,  0.04300,  0.00000,  0.00000,  0.01600,  0.00800,  0.00200,  0.00000,  0.00000],
[87,  101.13000,  18.63400,  17.89900,  15.02500,  4.64400,  4.31500,  3.65600,  3.12900,  2.99400,  1.14800,  0.99900,  0.83400,  0.59700,  0.56700,  0.25800,  0.24900,  0.22900,  0.17800,  0.13800,  0.06000,  0.05500,  0.00000,  0.00000,  0.02400,  0.01400,  0.00700,  0.00000,  0.00380],
[88,  103.91500,  19.23200,  18.48400,  15.44400,  4.82200,  4.48300,  3.78500,  3.24800,  3.10500,  1.20800,  1.05500,  0.87900,  0.63600,  0.60300,  0.28700,  0.27900,  0.25100,  0.19700,  0.15300,  0.07200,  0.06600,  0.00000,  0.00000,  0.03100,  0.02000,  0.01200,  0.00000,  0.00470],
[89,  106.75600,  19.84600,  19.08100,  15.87000,  4.99900,  4.65500,  3.91500,  3.37000,  3.21900,  1.26900,  1.11200,  0.92400,  0.67600,  0.64000,  0.31600,  0.30700,  0.27200,  0.21700,  0.16800,  0.08400,  0.07600,  0.00000,  0.00000,  0.03700,  0.02400,  0.01500,  0.00440,  0.00540],
[90,  109.65000,  20.47200,  19.69300,  16.30000,  5.18200,  4.83100,  4.04600,  3.49100,  3.33200,  1.33000,  1.16800,  0.96700,  0.71300,  0.67700,  0.34400,  0.33500,  0.29000,  0.23600,  0.18000,  0.09400,  0.08700,  0.00000,  0.00000,  0.04100,  0.02400,  0.01700,  0.00550,  0.00590],
[91,  112.59600,  21.10500,  20.31400,  16.73300,  5.36100,  5.00100,  4.17400,  3.60600,  3.44200,  1.38300,  1.21700,  1.00400,  0.74300,  0.70800,  0.36600,  0.35500,  0.30500,  0.24500,  0.18800,  0.09700,  0.09000,  0.00730,  0.00000,  0.04300,  0.02700,  0.01700,  0.00460,  0.00560],
[92,  115.60200,  21.75800,  20.94800,  17.16800,  5.54800,  5.18100,  4.30400,  3.72600,  3.55000,  1.44100,  1.27100,  1.04300,  0.77900,  0.73700,  0.38900,  0.37900,  0.32400,  0.25700,  0.19400,  0.10400,  0.09500,  0.00850,  0.00000,  0.04400,  0.02700,  0.01700,  0.00460,  0.00570],
[93,  118.66900,  22.42700,  21.60000,  17.61000,  5.73900,  5.36600,  4.43500,  3.84900,  3.66400,  1.50100,  1.32800,  1.08500,  0.81600,  0.77100,  0.41400,  0.40300,  0.33800,  0.27400,  0.20600,  0.10900,  0.10100,  0.00970,  0.00000,  0.04700,  0.02900,  0.01800,  0.00460,  0.00580],
[94,  121.79100,  23.10400,  22.26600,  18.05700,  5.93300,  5.54700,  4.56300,  3.97000,  3.77500,  1.55900,  1.38000,  1.12300,  0.84600,  0.79800,  0.43600,  0.42400,  0.35000,  0.28300,  0.21300,  0.11300,  0.10200,  0.00700,  0.00000,  0.04600,  0.02900,  0.01600,  0.00000,  0.00540],
[95,  124.98200,  23.80800,  22.95200,  18.51000,  6.13300,  5.73900,  4.69800,  4.09600,  3.89000,  1.62000,  1.43800,  1.16500,  0.88000,  0.82900,  0.46100,  0.44600,  0.36500,  0.29800,  0.21900,  0.11600,  0.10600,  0.00790,  0.00660,  0.04800,  0.02900,  0.01600,  0.00000,  0.00550],
[96,  128.24100,  24.52600,  23.65100,  18.97000,  6.33700,  5.93700,  4.83800,  4.22400,  4.00900,  1.68400,  1.49800,  1.20700,  0.91600,  0.86200,  0.48400,  0.47000,  0.38300,  0.31300,  0.22900,  0.12400,  0.11000,  0.01290,  0.01130,  0.05000,  0.03000,  0.01600,  0.00450,  0.00610],
[97,  131.55600,  25.25600,  24.37100,  19.43500,  6.54500,  6.13800,  4.97600,  4.35300,  4.12700,  1.74800,  1.55800,  1.24900,  0.95500,  0.89800,  0.51100,  0.49500,  0.39900,  0.32600,  0.23700,  0.13000,  0.11700,  0.01400,  0.01220,  0.05200,  0.03200,  0.01600,  0.00440,  0.00620],
[98,  134.93900,  26.01000,  25.10800,  19.90700,  6.76100,  6.34500,  5.11600,  4.48400,  4.24700,  1.81300,  1.62000,  1.29200,  0.99100,  0.93000,  0.53800,  0.52000,  0.41600,  0.34100,  0.24500,  0.13700,  0.12200,  0.01050,  0.00870,  0.05400,  0.03300,  0.01700,  0.00000,  0.00570],
[99,  138.39600,  26.78200,  25.86500,  20.38400,  6.98100,  6.55800,  5.25900,  4.61700,  4.36800,  1.88300,  1.68300,  1.33600,  1.02900,  0.96500,  0.56400,  0.54600,  0.43400,  0.35700,  0.25500,  0.14200,  0.12700,  0.01130,  0.00940,  0.05700,  0.03500,  0.01700,  0.00000,  0.00580],
[100,  141.92600,  27.57400,  26.64100,  20.86800,  7.20800,  6.77600,  5.40500,  4.75200,  4.49100,  1.95200,  1.74900,  1.37900,  1.06700,  1.00000,  0.59100,  0.57200,  0.45200,  0.37300,  0.26200,  0.14900,  0.13300,  0.01700,  0.01470,  0.05900,  0.03600,  0.01700,  0.00420,  0.00650],
[101,  146.52600,  28.38700,  27.43800,  21.35600,  7.44000,  7.00100,  5.55200,  4.88900,  4.61500,  2.02400,  1.81600,  1.42400,  1.10500,  1.03400,  0.61800,  0.59700,  0.47100,  0.38900,  0.27200,  0.15400,  0.13700,  0.01290,  0.01050,  0.06100,  0.03700,  0.01700,  0.00000,  0.00590],
[102,  149.20800,  29.22100,  28.25500,  21.85100,  7.67800,  7.23100,  5.70200,  5.02800,  4.74100,  2.09700,  1.88500,  1.46900,  1.14500,  1.07000,  0.64500,  0.62400,  0.49000,  0.40600,  0.28000,  0.16100,  0.14200,  0.01360,  0.01110,  0.06300,  0.03800,  0.01800,  0.00000,  0.00600],
[103,  152.97000,  30.08300,  29.10300,  22.35900,  7.93000,  7.47400,  5.86000,  5.17600,  4.87600,  2.18000,  1.96300,  1.52300,  1.19200,  1.11200,  0.68000,  0.65800,  0.51600,  0.42900,  0.29600,  0.17400,  0.15400,  0.01990,  0.01700,  0.07100,  0.04400,  0.02100,  0.00390,  0.00690],
[104,  156.28800,  30.88100,  29.98600,  22.90700,  8.16100,  7.73800,  6.00900,  5.33600,  5.01400,  2.23700,  2.03500,  1.55400,  1.23300,  1.14900,  0.72500,  0.70100,  0.53500,  0.44800,  0.31900,  0.19000,  0.17100,  0.02600,  0.02280,  0.08200,  0.05500,  0.03300,  0.00500,  0.00750],]

#from Scofield_HS import *
#K shell rates awful at Ca 
from Scofield_HS import ElementKShellTransitions
from Scofield_HS import ElementKShellRates
from Scofield_HS import ElementL1ShellTransitions
from Scofield_HS import ElementL1ShellRates
from Scofield_HS import ElementL2ShellTransitions
from Scofield_HS import ElementL2ShellRates
from Scofield_HS import ElementL3ShellTransitions
from Scofield_HS import ElementL3ShellRates
#Hartree-Fock works better for K shells
from Scofield_HF import ElementKShellTransitions
from Scofield_HF import ElementKShellRates
#import LShell_Chen
import LShell
import MShell
#Scofield's photoelectric dictionnary
import Scofield1973
ElementShellTransitions = [ElementKShellTransitions,LShell.ElementLShellTransitions,
                            ElementL1ShellTransitions,ElementL2ShellTransitions,ElementL3ShellTransitions,
                            MShell.ElementMShellTransitions]
ElementShellRates = [ElementKShellRates, LShell.ElementLShellRates,
                     ElementL1ShellRates,ElementL2ShellRates,ElementL3ShellRates,MShell.ElementMShellRates]

ElementXrays      = ['K xrays','L xrays','L1 xrays','L2 xrays','L3 xrays','M xrays']

def getsymbol(z):
    if (z > 0) and (z<=len(ElementList)):
        return ElementsInfo[int(z)-1][0]
    else:
        return None
    
def getname(z):
    if (z > 0) and (z<=len(ElementList)):
        return ElementsInfo[int(z)-1][4]
    else:
        return None
    
def getz(ele):
    if ele in ElementList:
        return ElementList.index(ele)+1
    else:
        return None
        
#fluorescence yields
def getomegak(ele):
    a=[0.0370,0.03112,5.44E-05,-1.250E-06]
    z=float(getz(ele))
    rhelp = a[0]
    for i in range(1,4):
        rhelp += a[i]*pow(z,i)
    rhelp = pow(rhelp,4)
    return rhelp/(1.0+rhelp)

def getomegal1(ele):
    index = LShell.ElementL1ShellConstants.index('omegaL1')
    return  LShell.ElementL1ShellValues[getz(ele)-1][index]

def getomegal2(ele):
    index = LShell.ElementL2ShellConstants.index('omegaL2')
    return  LShell.ElementL2ShellValues[getz(ele)-1][index]

def getomegal3(ele):
    index = LShell.ElementL3ShellConstants.index('omegaL3')
    return  LShell.ElementL3ShellValues[getz(ele)-1][index]

def getomegam1(ele):
    return MShell.getomegam1(ele)

def getomegam2(ele):
    return MShell.getomegam2(ele)

def getomegam3(ele):
    return MShell.getomegam3(ele)

def getomegam4(ele):
    return MShell.getomegam4(ele)

def getomegam5(ele):
    return MShell.getomegam5(ele)

#CosterKronig
def getCosterKronig(ele):
    return LShell.getCosterKronig(ele)

#Jump ratios following Veigele: Atomic Data Tables 5 (1973) 51-111. p 54 and 55
VEIGELE = True
def getjkVeigele(z):
    return (125.0/z) + 3.5

def getjl1Veigele(z):
    return 1.2

def getjl2Veigele(z):
    return 1.4

def getjl3Veigele(z):
    return (80.0/z) + 1.5

def getjm1Veigele(z):
    return 1.1

def getjm2Veigele(z):
    return 1.1

def getjm3Veigele(z):
    return 1.2

def getjm4Veigele(z):
    return 1.5

def getjm5Veigele(z):
    return (225.0/z) - 0.35

def getjk(z, veigele=None):
    if z > 101:z=101
    if veigele is None:
        veigele = VEIGELE
    if VEIGELE: return getjkVeigele(z)
    ele = getsymbol(z)
    if 'JK' in Scofield1973.dict[ele].keys():
        return Scofield1973.dict[ele]['JK']*1.0
    else:
        return None

def getjl1(z, veigele=None):
    if z > 101:z=101
    if veigele is None:
        veigele = VEIGELE
    if VEIGELE: return getjl1Veigele(z)
    ele = getsymbol(z)
    if 'JL1' in Scofield1973.dict[ele].keys():
        return Scofield1973.dict[ele]['JL1']*1.0
    else:
        return None

def getjl2(z, veigele=None):
    if z > 101:z=101
    if veigele is None:
        veigele = VEIGELE
    if VEIGELE: return getjl2Veigele(z)
    ele = getsymbol(z)
    if 'JL2' in Scofield1973.dict[ele].keys():
        return Scofield1973.dict[ele]['JL2']*1.0
    else:
        return None

def getjl3(z, veigele=None):
    if z > 101:z=101
    if veigele is None:
        veigele = VEIGELE
    if VEIGELE: return getjl3Veigele(z)
    ele = getsymbol(z)
    if 'JL3' in Scofield1973.dict[ele].keys():
        return Scofield1973.dict[ele]['JL3']*1.0
    else:
        return None

def getjm1(z, veigele=None):
    if z > 101:z=101
    if veigele is None:
        veigele = VEIGELE
    if VEIGELE: return getjm1Veigele(z)
    ele = getsymbol(z)
    if 'JM1' in Scofield1973.dict[ele].keys():
        return Scofield1973.dict[ele]['JM1']*1.0
    else:
        return None

def getjm2(z, veigele=None):
    if z > 101:z=101
    if veigele is None:
        veigele = VEIGELE
    if VEIGELE: return getjm2Veigele(z)
    ele = getsymbol(z)
    if 'JM3' in Scofield1973.dict[ele].keys():
        return Scofield1973.dict[ele]['JM2']*1.0
    else:
        return None

def getjm3(z, veigele=None):
    if z > 101:z=101
    if veigele is None:
        veigele = VEIGELE
    if VEIGELE: return getjm3Veigele(z)
    ele = getsymbol(z)
    if 'JM3' in Scofield1973.dict[ele].keys():
        return Scofield1973.dict[ele]['JM3']*1.0
    else:
        return None

def getjm4(z, veigele=None):
    if z > 101:z=101
    if veigele is None:
        veigele = VEIGELE
    if VEIGELE: return getjm4Veigele(z)
    ele = getsymbol(z)
    if 'JM4' in Scofield1973.dict[ele].keys():
        return Scofield1973.dict[ele]['JM4']*1.0
    else:
        return None

def getjm5(z, veigele=None):
    if z > 101:z=101
    if veigele is None:
        veigele = VEIGELE
    if VEIGELE: return getjm5Veigele(z)
    ele = getsymbol(z)
    if 'JM5' in Scofield1973.dict[ele].keys():
        return Scofield1973.dict[ele]['JM5']*1.0
    else:
        return None

def getLJumpWeight(ele,excitedshells=[1.0,1.0,1.0]):
    """
    wjump represents the probability for a vacancy to be created
    on the respective L-Shell by direct photoeffect on that shell
    """
    z = getz(ele)
    #weights due to photoeffect
    jl  = [getjl1(z), getjl2(z), getjl3(z)]
    wjump = []
    i = 0
    cum = 0.00
    for jump in jl:
        if jump is not None:
            v = excitedshells[i]*(jump-1.0)/jump
        else:
            v = 0.0
        wjump.append(v)
        cum += v
        i+=1
    for i in range(len(wjump)):
        if cum > 0.0:
            wjump[i] = wjump[i] / cum
        else:
            wjump[i] = 0.0
    return wjump

def getMJumpWeight(ele,excitedshells=[1.0,1.0,1.0,1.0,1.0]):
    """
    wjump represents the probability for a vacancy to be created
    on the respective M-Shell by direct photoeffect on that shell
    """
    z = getz(ele)
    #weights due to photoeffect
    jm  = [getjm1(z), getjm2(z), getjm3(z), getjm4(z), getjm5(z)]
    wjump = []
    i = 0
    cum = 0.00
    for jump in jm:
        if jump is not None:
            v = excitedshells[i]*(jump-1.0)/jump
        else:
            v = 0.0
        wjump.append(v)
        cum += v
        i+=1
    for i in range(len(wjump)):
        if cum > 0.0:
            wjump[i] = wjump[i] / cum
        else:
            wjump[i] = 0.0
    return wjump



def getPhotoWeight(ele,shelllist,energy, normalize = None, totals = None):
    #shellist = ['M1', 'M2', 'M3', 'M4', 'M5']
    # or ['L1', 'L2', 'L3']
    if normalize is None:normalize = True
    if totals is None: totals = False
    w = []
    z = getz(ele)
    if z > 101:
        element = getsymbol(101)
        if z > 104: 
            elework = getsymbol(104)
        else:
            elework = ele
    else:
        elework = ele
        element = ele
    if totals: totalPhoto = []
    for key in shelllist:
        wi = 0.0
        totalPhotoi = 0.0
        if key != "all other":
            bindingE = Element[elework]['binding'][key]
        else:
            bindingE = 0.001
        if (key == "all other") and (key not in Scofield1973.dict[element].keys()):
            doit = False
        else:
            doit = True

        if doit and bindingE > 0.0:
            if energy >= bindingE:
                deltae = energy - bindingE
                if key != "all other":
                    ework  = Scofield1973.dict[element]['binding'][key]+deltae
                else:
                    ework  = energy
                if ework > Scofield1973.dict[element]['energy'][-1]:
                    #take last
                    wi =  Scofield1973.dict[element][key][-1]
                    totalPhotoi=Scofield1973.dict[element]['total'][-1]
                else:
                    #interpolate
                    i=0
                    while (Scofield1973.dict[element]['energy'][i] < ework):
                        i+=1
                    #if less than 5 eV take that value (Scofield calculations
                    #do not seem to be self-consistent in tems of energy grid
                    #and binding energy -see Lead with e=2.5 -> ework = 2.506 
                    #that is below the binding energy of Scofield)
                    if False and (Scofield1973.dict[element]['energy'][i] - ework) < 0.005:
                        #this does not work for Cd and E=3.5376"
                        print "Not interpolate for key = ",key,'ework = ',ework,"taken ",Scofield1973.dict[element]['energy'][i]
                        wi =  Scofield1973.dict[element][key][i]
                    elif (key != 'all other') and Scofield1973.dict[element]['energy'][i-1] < Scofield1973.dict[element]['binding'][key]:
                        wi =  Scofield1973.dict[element][key][i]
                        totalPhotoi = Scofield1973.dict[element]['total'][i]
                    elif Scofield1973.dict[element][key][i-1] <= 0.0:
                        #equivalent to previous case, solves problem of Fr at excitation = 3.0
                        wi =  Scofield1973.dict[element][key][i]
                        totalPhotoi = Scofield1973.dict[element]['total'][i]
                    else:
                        #if element == "Fr":
                        #    print "energy = ",energy," ework = ",ework
                        #    print Scofield1973.dict[element]['energy'][i]    
                        #    print Scofield1973.dict[element]['energy'][i-1]
                        #    print Scofield1973.dict[element][key][i]
                        #    print Scofield1973.dict[element][key][i-1]
                        #    print type( Scofield1973.dict[element][key][i-1] ) 
                        x2 = Numeric.log(Scofield1973.dict[element]['energy'][i])
                        x1 = Numeric.log(Scofield1973.dict[element]['energy'][i-1])
                        y2 = Numeric.log(Scofield1973.dict[element][key][i])
                        y1 = Numeric.log(Scofield1973.dict[element][key][i-1])
                        slope = (y2 - y1)/(x2 - x1)
                        wi = Numeric.exp(y1 + slope * (Numeric.log(ework) - x1))
                        if totals:
                            y2 = Numeric.log(Scofield1973.dict[element]['total'][i])
                            y1 = Numeric.log(Scofield1973.dict[element]['total'][i-1])
                            totalPhotoi = Numeric.exp(y1 + slope * (Numeric.log(ework) - x1))
                        
                        
        w += [wi]
        if totals:
            totalPhoto += [totalPhotoi]
    if normalize:
        total = sum(w)
        for i in range(len(w)):
            if total > 0.0:
                w[i] = w[i]/total
            else:
                w[i] = 0.0
    if totals:
        return w, totalPhoto
    else:
        return w

def _getFluorescenceWeights(ele, energy, normalize = None, cascade = None):
    if normalize is None:normalize = True
    if cascade   is None:cascade   = False
    if type(ele) == type(" "):
        pass
    else:
        ele = getsymbol(int(ele))
    wall = getPhotoWeight(ele,['K','L1','L2','L3','M1','M2','M3','M4','M5','all other'],energy, normalize=True)
    #weights due to Coster - Kronig transitions
    #k shell is not affected
    ck= LShell.getCosterKronig(ele)
    
    if cascade and (sum(wall[1:4]) > 0.0) and (wall[0] > 0.0):
        #l shell (considering holes due to k shell transitions)
        #I assume that approximately the auger transitions give
        #single equaly distributed vacancies
        # I guess this will be better than ignoring them
        if Element[ele]['omegak'] > 0.001:
            auger = 0.32 * (1.0 - Element[ele]['omegak'])
            #assume rest goes to other shells ...
            cor   = [auger,
                     auger + Element[ele]['KL2']['rate'] * Element[ele]['omegak'],
                     auger + Element[ele]['KL3']['rate'] * Element[ele]['omegak']]
            w = [wall[1]+cor[0] * wall[0], 
                 wall[2]+cor[1] * wall[0],
                 wall[3]+cor[2] * wall[0]]
        else:
            cor = 0.3 * wall[0]
            w = [wall[1]+cor, wall[2]+cor, wall[3]+cor]
        mbuffer = sum(w)/5.0
    else:
        #l shell (neglecting holes due to k shell transitions)
        w = [wall[1], wall[2], wall[3]]
    w[0] *=  1.0
    w[1] *= (1.0 + ck['f12'] * w[0])
    w[2] *= (1.0 + ck['f13'] * w[0] + ck['f23'] * w[1])
    wall[1] = w[0] * 1.0
    wall[2] = w[1] * 1.0
    wall[3] = w[2] * 1.0
    #mshell
    ck= MShell.getCosterKronig(ele)
    if cascade and (sum(wall[4:]) > 0):
        cor = [0.0, 0.0, 0.0, 0.0, 0.0]
        augercor = 0.0
        if wall[0] > 0.0:
            #K shell
            if 'KM2' in Element[ele]['K xrays']:
                cor[1] += wall[0] * Element[ele]['KM2']['rate'] * \
                           Element[ele]['omegak']                       
            if 'KM3' in Element[ele]['K xrays']:
                cor[2] += wall[0] * Element[ele]['KM3']['rate'] * \
                           Element[ele]['omegak']
            #auger K transitions (5 % total of shells M1, M2, M3)
            cor[0] += wall[0] * 0.05 * (1.0 - Element[ele]['omegak'])
            cor[1] += wall[0] * 0.05 * (1.0 - Element[ele]['omegak'])
            cor[2] += wall[0] * 0.05 * (1.0 - Element[ele]['omegak'])
            cor[3] += wall[0] * 0.01 * (1.0 - Element[ele]['omegak'])
            cor[4] += wall[0] * 0.01 * (1.0 - Element[ele]['omegak'])
        
        if sum(wall[1:4]) > 0:
            #L shell
            #X rays I can take them rigorously
            mlist = ['M1','M2','M3','M4','M5']
            i = 0
            #for the auger I take 95% of the value and
            #equally distribute it among the shells    
            augerfactor = 0.95/ 5.0
            augercor    = 0.0
            for key in ['L1 xrays', 'L2 xrays', 'L3 xrays']:
                i = i + 1
                if   i == 1:
                    omega=Element[ele]['omegal1']
                    auger= 1.0 - omega \
                           - Element[ele]['CosterKronig']['L']['f12'] \
                           - Element[ele]['CosterKronig']['L']['f13']
                    augercor += augerfactor * auger
                elif i == 2:
                    omega=Element[ele]['omegal2']
                    auger= 1.0 - omega \
                           - Element[ele]['CosterKronig']['L']['f23']
                    augercor += augerfactor * auger
                elif i == 3:
                    omega=Element[ele]['omegal3']
                    auger= 1.0 - omega
                    augercor += augerfactor * auger
                else:
                    print "Error unknown shell, Please report"
                    omega = 0.0
                    #for the elements
                    
                #I consider Coster-Kronig for L1
                if (i == 1) and (Element[ele]['Z'] >= 80):
                    #f13 is the main transition 
                    if Element[ele]['Z'] >= 90:
                        #L1-L3M5 is ~ 40 %
                        #L1-L3M4 is ~ 32 %
                        #rest is other shells
                        cor[3] += 0.32 * wall[1] * \
                                  Element[ele]['CosterKronig']['L']['f13']
                        cor[4] += 0.43 * wall[1] * \
                                  Element[ele]['CosterKronig']['L']['f13']
                        if Element[ele]['Z'] > 90:
                            cor[2] += 0.5 * wall[1] * \
                                  Element[ele]['CosterKronig']['L']['f13']  
                    else:
                        #L1-L3M5 is ~ 43 %
                        #L1-L3M4 is ~ 32 %
                        #rest is other shells
                        cor[3] += 0.32 * wall[1] * \
                                  Element[ele]['CosterKronig']['L']['f13']
                        cor[4] += 0.44 * wall[1] * \
                                  Element[ele]['CosterKronig']['L']['f13']
                #L2
                elif (i == 2) and (Element[ele]['Z'] >= 90):
                    if Element[ele]['Z'] >= 94:
                        #L2-L3M5 ~ 3 %
                        #L2-L3M4 ~ 50%
                        cor[3] += 0.50 * wall[2] * \
                            Element[ele]['CosterKronig']['L']['f23']    
                        cor[4] += 0.03 * wall[2] * \
                            Element[ele]['CosterKronig']['L']['f23']    
                    else:
                        #L2-L3M5 ~ 6 %
                        cor[4] += 0.06 * wall[2] * \
                            Element[ele]['CosterKronig']['L']['f23']
                elif (i==3):
                    #missing pages from article
                    pass
                if Element[ele].has_key(key):
                    for t in Element[ele][key]:
                        if t[2:] in mlist:
                            index = mlist.index(t[2:])
                            cor[index] +=  Element[ele][t]['rate'] * \
                                            wall[i] * omega
        cor[0] += augercor
        cor[1] += augercor
        cor[2] += augercor
        cor[3] += augercor
        cor[4] += augercor
        w = [wall[4]+cor[0], wall[5]+cor[1], wall[6]+cor[2], wall[7]+cor[3], wall[8]+cor[4]]
    else:
        w = [wall[4], wall[5], wall[6], wall[7], wall[8]]
    w[0] *=  1.0
    w[1] *= (1.0 + ck['f12'] * w[0])
    w[2] *= (1.0 + ck['f13'] * w[0] + ck['f23'] * w[1])
    w[3] *= (1.0 + ck['f14'] * w[0] + ck['f24'] * w[1] + ck['f34'] * w[2])
    w[4] *= (1.0 + ck['f15'] * w[0] + ck['f25'] * w[1] + ck['f35'] * w[2] + ck['f45'] * w[3])
    wall[4] = w[0] * 1.0
    wall[5] = w[1] * 1.0
    wall[6] = w[2] * 1.0
    wall[7] = w[3] * 1.0
    wall[8] = w[4] * 1.0
    
    #weights due to omega
    omega = [ getomegak(ele),
              getomegal1(ele), getomegal2(ele), getomegal3(ele),
              getomegam1(ele), getomegam2(ele), getomegam3(ele), getomegam4(ele), getomegam5(ele)]
    w = wall[0:9]
    for i in range(len(w)):
        w[i] *= omega[i]
    if normalize:
        cum = sum(w)
        for i in range(len(w)):
            if cum > 0.0:
                w[i] /= cum
    return w

def getEscape(matrix, energy, ethreshold=None, ithreshold=None, nthreshold = None, 
                        alphain = None, cascade = None, fluorescencemode=None):
    """
    getEscape(matrixlist, energy, 
              ethreshold=None, ithreshold=None, nthreshold = None,
              alphain = None)
    matrixlist is a list of the form [material, density, thickness]
    energy is the incident beam energy
    ethreshold is the difference in keV between two peaks to be considered the same
    ithreshold is the minimum absolute peak intensity to consider
    nthreshold is maximum number of escape peaks to consider
    alphain  is the incoming beam angle with detector surface
    It gives back a list of the form  [[energy0, intensity0, label0], 
                                       [energy1, intensity1, label1],
                                       ....
                                       [energyn, intensityn, labeln]]
    with the escape energies, intensities and labels
    """
    if alphain  is None: alphain  = 90.0
    if fluorescencemode is None:fluorescencemode = False
    sinAlphaIn   = Numeric.sin(alphain * (Numeric.pi)/180.)
    sinAlphaOut  = 1.0
    elementsList = None
    if cascade is None:cascade=False
    if elementsList is None:
        #get material elements and concentrations
        eleDict = getMaterialMassFractions([matrix[0]], [1.0])
        if eleDict == {}: return {}
        #sort the elements according to atomic number (not needed because the output will be a dictionnary)
        keys = eleDict.keys()
        elementsList = [[getz(x),x] for x in keys]
        elementsList.sort()
        #do the job

    outputDict = {}
    shelllist = ['K', 'L1', 'L2', 'L3','M1', 'M2', 'M3', 'M4', 'M5']
    for z,ele in elementsList:
        #use own unfiltered dictionnary
        elementDict = _getUnfilteredElementDict(ele, energy)
        outputDict[ele] ={}
        outputDict[ele]['mass fraction'] = eleDict[ele]
        outputDict[ele]['rates'] = {}
        #get the fluorescence term for all shells
        fluoWeights = _getFluorescenceWeights(ele, energy, normalize = False,
                                                cascade=cascade)
        outputDict[ele]['rays'] = elementDict['rays'] * 1
        for rays in elementDict['rays']:
            outputDict[ele][rays] = []
            rates    = []
            energies = []
            transitions = elementDict[rays]
            for transition in transitions:
                outputDict[ele][rays] += [transition]
                outputDict[ele][transition]={}
                outputDict[ele][transition]['rate'] = 0.0
                if transition[0] == "K":
                    rates.append(fluoWeights[0] *  elementDict[transition]['rate'])              
                else:
                    rates.append(fluoWeights[shelllist.index(transition[0:2])] * elementDict[transition]['rate'])
                ene = elementDict[transition]['energy']
                energies += [ene]
                outputDict[ele][transition]['energy'] = ene
                
            #matrix term
            formula   = matrix[0]
            thickness = matrix[1] * matrix[2]
            energies += [energy]
            allcoeffs   =  getMaterialMassAttenuationCoefficients(formula,1.0,energies)
            mutotal  = allcoeffs['total']
            #muphoto  = allcoeffs['photo']
            muphoto  = getMaterialMassAttenuationCoefficients(ele,1.0,energy)['photo']
            # correct respect to Reed and Ware
            # because there can be more than one element and
            # I also weight the mass fraction
            notalone = (muphoto[-1]/mutotal[-1]) *\
                        0.5 * outputDict[ele]['mass fraction'] 
            del energies[-1]
            i = 0
            for transition in transitions:
                trans = (mutotal[i]/sinAlphaOut)/(mutotal[-1]/sinAlphaIn)
                trans = notalone * \
                        (1.0 - trans * Numeric.log(1.0 + 1.0/trans)) 
                if thickness > 0.0:
                    #extremely thin case
                    trans0 = notalone * thickness * mutotal[-1]/sinAlphaIn
                    trans = min(trans0, trans)
                rates[i] *=  trans
                outputDict[ele][transition]['rate'] = rates[i]
                i += 1
            outputDict[ele]['rates'][rays] = sum(rates)
            #outputDict[ele][rays]= Element[ele]['rays'] * 1
    peaklist = []
    for key in outputDict:
        rays = []
        if 'M xrays' in outputDict[key]:
            rays += outputDict[key]['M xrays']
        if 'L xrays' in outputDict[key]:
            rays += outputDict[key]['L xrays']
        if 'K xrays' in outputDict[key]:
            rays += outputDict[key]['K xrays']
        for label in rays:
            if fluorescencemode:            
                peaklist.append([outputDict[key][label]['energy'],
                                 outputDict[key][label]['rate'], 
                                 key+' '+label.replace('*','')])
            else:
                peaklist.append([energy - outputDict[key][label]['energy'],
                             outputDict[key][label]['rate'], 
                             key+' '+label.replace('*','')])
    
    return _filterPeaks(peaklist, ethreshold = ethreshold,
                                  ithreshold = ithreshold,
                                  nthreshold = nthreshold,
                                  absoluteithreshold = True,
                                  keeptotalrate = False)
    
        
    #return outputDict 

    
def _filterPeaks(peaklist, ethreshold = None, ithreshold = None,
                 nthreshold = None,
                 absoluteithreshold=None,
                 keeptotalrate=None):
    """
    Given a list of peaks of the form [[energy0, intensity0, label0], 
                                       [energy1, intensity1, label1],
                                       ....
                                       [energyn, intensityn, labeln]]
    gives back a filtered list of the same form
    ethreshold -> peaks within that threshold are considered one
    ithreshold -> intensity threshold relative to maximum unless
                   absoluteithreshold is set to True
    The total rate is kept unless keeptotal rate is set to false (for instance for
    the escape peak calculation
    """
    if absoluteithreshold is None:absoluteithreshold=False
    div = []
    for i in range(len(peaklist)):
        if peaklist[i][1] > 0.0:
            div.append([peaklist[i][0],[peaklist[i][1],peaklist[i][0]],peaklist[i][2]])
    #div =[[peaklist[i][0],[peaklist[i][1],peaklist[i][0]],peaklist[i][2]] for i in range(len(peaklist))]
    div.sort()
    totalrate = sum([x[1] for x in peaklist])
    newpeaks     =[div[i][1] for i in range(len(div))]
    newpeaksnames=[div[i][2] for i in range(len(div))]
    tojoint=[]
    deltaonepeak = ethreshold
    mix = []

    if len(newpeaks) > 1:
        for i in range(len(newpeaks)):
            #print "i = ",i,"energy = ",newpeaks[i][1], \
            #         " rate = ",newpeaks[i][0], \
            #         "name = ",newpeaksnames[i]
            for j in range(i,len(newpeaks)):
                if i != j:
                    if abs(newpeaks[i][1]-newpeaks[j][1]) < deltaonepeak:
                        if len(tojoint):
                            if (i in tojoint[-1]) and (j in tojoint[-1]):
                                #print "i and j already there"
                                pass
                            elif (i in tojoint[-1]):
                                #print "i was there"
                                tojoint[-1]+=[j]
                            elif (j in tojoint[-1]):
                                #print "j was there"
                                tojoint[-1]+=[i]
                            else:
                                tojoint.append([i,j])
                        else:
                            tojoint.append([i,j])
        if len(tojoint):
            mix=[]
            mixname=[]
            newpeaksbuffer=newpeaks[:]
            newpeaksnamesbuffer=newpeaksnames[:]
            iDelete = []
            for _group in tojoint:
                rate = 0.0
                rateMax  = 0.0
                for i in _group:
                    rate += newpeaks[i][0]
                    if newpeaks[i][0] > rateMax:
                        rateMax = newpeaks[i][0]
                        iMax    = i
                    iDelete += [i]
                transition = newpeaksnames[iMax]
                ene  = 0.0
                for i in _group:
                    ene  += newpeaks[i][0] * newpeaks[i][1]/rate
                mix.append([ene,rate,transition])
            iDelete.sort()
            iDelete.reverse()
            for i in iDelete:
                del newpeaks[i]
                del newpeaksnames[i]
    output = []
    for i in range(len(newpeaks)):
        output.append([newpeaks[i][1], newpeaks[i][0], newpeaksnames [i]])
    for peak in mix:
        output.append(peak)
    output.sort()
    
    #intensity threshold
    if len(output) <= 1:return output
    if ithreshold is not None:        
        imax = max([x[1] for x in output])
        if absoluteithreshold:
            threshold = ithreshold
        else:
            threshold = ithreshold * imax
        for i in range(-len(output)+1,1):
            if output[i][1] < threshold:
                del output[i]
                
    #number threshold
    if nthreshold is not None:
        if nthreshold < len(output):
            div = [[x[1],x] for x in output]
            div.sort()
            div.reverse()
            div = div[:nthreshold]
            output = [x[1] for x in div]
            
    #recover original rates
    currenttotal = sum([x[1] for x in output])
    if currenttotal > 0:
        totalrate = totalrate/currenttotal
        output = [[x[0],x[1]*totalrate,x[2]] for x in output]

    return output


def _getAttFilteredElementDict(elementsList,
                               attenuators= None,
                               detector   = None,
                               energy = None):
    if energy is None:      energy = 100.
    if attenuators is None: attenuators = []
    outputDict = {}
    for group in elementsList:
        ele  = group[1] * 1
        if not outputDict.has_key(ele):
            outputDict[ele] = {}
            outputDict[ele]['rays'] = []
        raysforloop = [group[2] + " xrays"]
        elementDict = _getUnfilteredElementDict(ele, energy)
        for rays in raysforloop:
            if rays not in elementDict.keys():continue
            else:outputDict[ele]['rays'].append(rays)
            outputDict[ele][rays] = []
            rates    = []
            energies = []
            transitions = elementDict[rays]
            for transition in transitions:
                outputDict[ele][rays] += [transition]
                outputDict[ele][transition]={}
                ene = elementDict[transition]['energy'] * 1
                energies += [ene]
                rates.append(elementDict[transition]['rate'] * 1.0)
                outputDict[ele][transition]['energy'] = ene
            #I do not know if to include this loop in the previous one (because rates are 0.0 sometimes)    
            #attenuators
            coeffs = Numeric.zeros(len(energies), Numeric.Float)
            for attenuator in attenuators:
                formula   = attenuator[0]
                thickness = attenuator[1] * attenuator[2]
                coeffs +=  thickness * Numeric.array(getMaterialMassAttenuationCoefficients(formula,1.0,energies)['total'])
            try:
                trans = Numeric.exp(-coeffs)
            except OverflowError:
                #deal with underflows reported as overflows
                trans = Numeric.zeros(len(energies), Numeric.Float)
                for i in range(len(energies)):
                    coef = coeffs[i]
                    if coef < 0.0:
                        raise "ValueError","Positive exponent in attenuators transmission term"
                    else:
                        try:
                            trans[i] = Numeric.exp(-coef)
                        except OverflowError:
                            #if we are here we know it is not an overflow and trans[i] has the proper value
                            pass
            for i in range(len(rates)):
                rates[i] *= trans[i]
            #detector term
            if detector is not None:
                formula   = detector[0]
                thickness = detector[1] * detector[2]
                coeffs   =  thickness * Numeric.array(getMaterialMassAttenuationCoefficients(formula,1.0,energies)['total'])
                try:
                    trans = (1.0 - Numeric.exp(-coeffs))
                except OverflowError:
                    #deal with underflows reported as overflows
                    trans = Numeric.ones(len(energies), Numeric.Float)
                    for i in range(len(energies)):
                        coef = coeffs[i]
                        if coef < 0.0:
                            raise "ValueError","Positive exponent in detector transmission term"
                        else:
                            try:
                                trans[i] = 1.0 - Numeric.exp(-coef)
                            except OverflowError:
                                #if we are here we know it is not an overflow and trans[i] has the proper value
                                pass
                for i in range(len(rates)):
                    rates[i] *= trans[i]
            i = 0
            for transition in transitions:
                outputDict[ele][transition]['rate'] = rates[i] * 1
                i += 1
    return outputDict

def getMultilayerFluorescence(multilayer0,
                              energyList,
                              layerList = None,
                              weightList=None,
                              flagList  = None,
                              fulloutput = None,
                              beamfilters = None,
                              elementsList = None,
                              attenuators  = None,
                              alphain      = None,
                              alphaout     = None,
                              cascade = None,
                              detector= None,
                              forcepresent=None,
                              secondary=None):

    if multilayer0 is None:return []
    if secondary is None:secondary=False
    if len(multilayer0):
        if type(multilayer0[0]) != types.ListType:
            multilayer=[multilayer0 * 1]
        else:
            multilayer=multilayer0 * 1
    if fulloutput  is None:fulloutput  = 0
    if (type(energyList) != types.ListType) and \
       (type(energyList) != Numeric.ArrayType):
        energyList = [energyList]
        
    energyList = Numeric.array(energyList)
    if layerList is None:layerList = range(len(multilayer))
    if type(layerList) != types.ListType:
        layerList = [layerList]
    if elementsList is not None:
        if type(elementsList) != types.ListType:
            elementsList = [elementsList]

    if weightList is not None:
        if (type(weightList) != types.ListType) and \
           (type(weightList) != Numeric.ArrayType):
            weightList = [weightList]
        weightList = Numeric.array(weightList)
    else:
        weightList = Numeric.ones(len(energyList)).astype(Numeric.Float)
    if flagList is not None:
        if (type(flagList) != types.ListType) and \
           (type(flagList) != Numeric.ArrayType):
            flagList = [flagList]
        flagList   = Numeric.array(flagList)
    else:
        flagList = Numeric.ones(len(energyList)).astype(Numeric.Float)
            
    optimized = 0
    if beamfilters is None:beamfilters = []
    if len(beamfilters):
        if type(beamfilters[0]) != types.ListType:
            beamfilters=[beamfilters]
    if elementsList is not None:
        if len(elementsList):
            if type(elementsList[0]) == types.ListType:
                if len(elementsList[0]) == 3:
                    optimized = 1

    if attenuators is None:attenuators = []
    if beamfilters is None:beamfilters = []
    if alphain  is None: alphain =  45.0
    if alphaout is None: alphaout = 45.0
    sinAlphaIn  = Numeric.sin(alphain  * Numeric.pi / 180.)
    sinAlphaOut = Numeric.sin(alphaout * Numeric.pi / 180.)
    origattenuators = attenuators * 1
    newbeamfilters  = beamfilters * 1

    #normalize incoming beam
    i0 = Numeric.nonzero(flagList>0)
    weightList = Numeric.take(weightList, i0).astype(Numeric.Float)
    energyList = Numeric.take(energyList, i0).astype(Numeric.Float)
    flagList   = Numeric.take(flagList, i0).astype(Numeric.Float)
    #normalize selected weights
    total = sum(weightList)
    if 0:
        #old way
        for beamfilter in beamfilters:
            formula   = beamfilter[0]
            thickness = beamfilter[1] * beamfilter[2]
            coeffs   =  thickness * Numeric.array(getMaterialMassAttenuationCoefficients(formula,1.0,energyList)['total'])
            try:
                trans = Numeric.exp(-coeffs)
            except OverflowError:
                for coef in coeffs:
                    if coef < 0.0:
                        raise "ValueError","Positive exponent in attenuators transmission term"    
                trans = 0.0 * coeffs            
            weightList = weightList * trans
    else:
        pass
        #new way will be made later
        #formula  = []
        #thickness = []
        #for beamfilter in newbeamfilters:
        #    formula.append(beamfilter[0] * 1)
        #    thickness.append(beamfilter[1] * beamfilter[2])
        #trans = getMaterialTransmission(formula, thickness, energyList,
        #        density=1.0, thickness = sum(thickness))['transmission']
        #weightList = weightList * trans
    if total <= 0.0:raise "ValueError","Sum of weights lower or equal to 0"
    weightList = weightList / total


    #forcepresent is to set concentration 1 for the fit
    #useless if elementsList is not given
    if forcepresent is None:forcepresent=0
    forcedElementsList = []  
    if elementsList is not None:
        if forcepresent:
            forcedElementsList = elementsList * 1
            keys = []            
            for ilayer in range(len(multilayer)):
                pseudomatrix = multilayer[ilayer] * 1
                eleDict = getMaterialMassFractions([pseudomatrix[0]], [1.0])
                keys += eleDict.keys()

            for ele in keys:
                todelete = []
                for i in range(len(forcedElementsList)):
                    group = forcedElementsList[i]
                    if optimized: groupElement = group[1] * 1
                    else: groupElement = group * 1
                    if ele == groupElement:
                        todelete.append(i)
                todelete.reverse()
                for i in todelete:
                    del forcedElementsList[i]
        else:
            forcedElementsList = [] 
            
    #print "forcedElementsList = ",forcedElementsList
    #import time
    #t0 = time.time()
    result       = []
    dictListList = []
    elementsListFinal = []
    for ilayer in range(len(multilayer)):
        dictList     = []
        if ilayer not in layerList:continue
        if ilayer > 0:
            #arrange attenuators
            origattenuators.append(multilayer[ilayer-1] * 1)
            origattenuators[-1][2] = origattenuators[-1][2]/sinAlphaOut
            #arrange beamfilters
            newbeamfilters.append(multilayer[ilayer-1] * 1)
            newbeamfilters[-1][2] = newbeamfilters[-1][2]/sinAlphaIn
        pseudomatrix = multilayer[ilayer] * 1
        newelementsList = []
        eleDict = getMaterialMassFractions([pseudomatrix[0]], [1.0])
        if eleDict == {}:
            raise "ValueError", "Invalid layer material %s" % pseudomatrix[0]
        keys = eleDict.keys()
        if elementsList is None:
            newelementsList = keys
            for key in keys:
                if key not in elementsListFinal:
                    elementsListFinal.append(key)                
        else:
            newelementsList = []
            if optimized:
                for ele in keys:
                    for group in elementsList:
                        if ele == group[1]:
                            newelementsList.append(group)
            else:
                for ele in keys:
                    for group in elementsList:
                        if ele == group:
                            newelementsList.append(group)
            for group in forcedElementsList:
                newelementsList.append(group * 1)
                if optimized:
                    eleDict[group[1] * 1] = {}
                    eleDict[group[1] * 1] = 1.0
                else: 
                    eleDict[group * 1] = {}
                    eleDict[group * 1] = 1.0   
            if not len(newelementsList):
                dictList.append({})
                result.append({})
                continue
                
        #here I could recalculate the dictionnary
        if optimized:
            userElementDict = _getAttFilteredElementDict(newelementsList,
                               attenuators= origattenuators,
                               detector   = detector,
                               energy = max(energyList))
            workattenuators = None
            workdetector    = None
        else:
            userElementDict = None
            workattenuators = origattenuators * 1
            if detector is not None:
                workdetector = detector * 1
            else:
                workdetector = None

        newweightlist = Numeric.ones(weightList.shape,Numeric.Float)
        if len(newbeamfilters):
            coeffs = Numeric.zeros(len(energyList), Numeric.Float)
            for beamfilter in newbeamfilters:
                formula   = beamfilter[0]
                thickness = beamfilter[1] * beamfilter[2]
                coeffs   +=  thickness * Numeric.array(getMaterialMassAttenuationCoefficients(formula,1.0,energyList)['total'])
            try:
                trans = Numeric.exp(-coeffs)
            except OverflowError:
                #deal with underflows reported as overflows
                trans = Numeric.zeros(len(energyList), Numeric.Float)
                for i in range(len(energyList)):
                    coef = coeffs[i]
                    if coef < 0.0:
                        raise "ValueError","Positive exponent in attenuators transmission term"
                    else:
                        try:
                            trans[i] = Numeric.exp(-coef)
                        except OverflowError:
                            #if we are here we know it is not an overflow and trans[i] has the proper value
                            pass
            newweightlist = weightList * trans
        else:
            newweightlist = weightList * 1

        #nobody warrants the list ordered
        if optimized:
            newelementsListWork =  newelementsList * 1            
        else:
            newelementsListWork = [newelementsList * 1]
        for justone in newelementsListWork:
            if optimized:
                if len(justone[2]) == 2:
                    shellIdent = justone[2].upper()
                elif justone[2].upper() == 'L':
                    shellIdent = 'L3'
                elif justone[2].upper() == 'M':
                    shellIdent = 'M5'
                elif justone[2].upper() == 'K':
                    shellIdent = 'K'
                else:
                    raise "ValueError","Unknown Element shell %s" % justone[2]
                bindingEnergy = Element[justone[1]]['binding'][shellIdent]
                nrgi = Numeric.nonzero(energyList >= bindingEnergy)
                if len(nrgi) == 0:nrgi=[0]
                justoneList = [justone]                
            else:
                justoneList = justone
                nrgi = range(len(energyList))
            for iene in nrgi:
                energy   = energyList[iene]  * 1.0
                #print "before origattenuators = ",origattenuators
                dict = getFluorescence(pseudomatrix, energy,
                                attenuators = workattenuators,
                                alphain = alphain,
                                alphaout = alphaout,
                                #elementsList = newelementsList,
                                elementsList = justoneList,
                                cascade  = cascade,
                                detector = workdetector,
                                userElementDict = userElementDict)
                #print "after origattenuators = ",origattenuators
                if optimized:
                    #give back with concentration 1
                    for ele in dict.keys():
                        dict[ele]['weight'] = newweightlist[iene] * 1.0
                        dict[ele]['mass fraction'] = eleDict[ele] * 1.0
                else:
                    #already corrected for concentration
                    for ele in dict.keys():
                        dict[ele]['weight'] = newweightlist[iene] * eleDict[ele]
                        dict[ele]['mass fraction'] = eleDict[ele] * 1.0
                #if ele == "Cl":print "dict[ele]['mass fraction'] ",eleDict[ele]
                dictList.append(dict)
        #secondary fluorescence term from next layers
        if secondary:
            newweightlist2 = newweightlist * 1        
            for ilayer2 in range(len(multilayer)):
                if ilayer2 <= ilayer:continue
                #get beam intensity at the layer
                pseudomatrix2 = multilayer[ilayer2]   * 1
                beamfilter    = multilayer[ilayer2-1] * 1
                formula   = beamfilter[0]
                thickness = beamfilter[1] * beamfilter[2]
                coeffs   =  thickness * Numeric.array(getMaterialMassAttenuationCoefficients(formula,1.0,energyList)['total'])
                try:
                    trans = Numeric.exp(-coeffs)
                except OverflowError:
                    #deal with underflows reported as overflows
                    trans = Numeric.zeros(len(energyList), Numeric.Float)
                    for i in range(len(energyList)):
                        coef = coeffs[i]
                        if coef < 0.0:
                            raise "ValueError","Positive exponent in attenuators transmission term"
                        else:
                            try:
                                trans[i] = Numeric.exp(-coef)
                            except OverflowError:
                                #if we are here we know it is not an overflow and trans[i] has the proper value
                                pass
                newweightlist2 = newweightlist2 * trans
                #get beam2
                for iene in  range(len(energyList)):
                    energy = energyList[iene]  * 1.0
                    escape = getEscape(pseudomatrix2, 
                                       energy,
                                       alphain    = alphain,
                                       cascade    = True,
                                       #up to 20 peaks
                                       nthreshold = 20,
                                       ithreshold = 1.0e-5,
                                       ethreshold = 0.010,
                                       fluorescencemode=True)
                    if not len(escape):continue
                    energyList2 = [x[0] for x in escape]
                    weightList2 = Numeric.array([x[1] for x in escape]) * newweightlist2[iene]
                    flagList2   = Numeric.ones(weightList2.shape,Numeric.Float)
                    #correct for attenuation in intermediate layers!!!
                    weightList3 = 1.0 * weightList2
                    for ilayer3 in range(len(multilayer)):
                        if ilayer3 >= ilayer2:continue    
                        if ilayer3 <= ilayer: continue
                        #I have an intermediate layer
                        beamfilter = multilayer[ilayer3] * 1
                        formula   = beamfilter[0]
                        thickness = beamfilter[1] * beamfilter[2]
                        coeffs   =  thickness * Numeric.array(getMaterialMassAttenuationCoefficients(formula,1.0,energyList2)['total'])
                        try:
                            trans = Numeric.exp(-coeffs)
                        except OverflowError:
                            #deal with underflows reported as overflows
                            trans = Numeric.zeros(len(energyList2), Numeric.Float)
                            for i in range(len(energyList2)):
                                coef = coeffs[i]
                                if coef < 0.0:
                                    raise "ValueError","Positive exponent in attenuators transmission term"
                                else:
                                    try:
                                        trans[i] = Numeric.exp(-coef)
                                    except OverflowError:
                                        #if we are here we know it is not an overflow and trans[i] has the proper value
                                        pass
                        weightList3 = weightList3 * trans
                        
                    for iene2 in range(len(energyList2)):
                        energy = energyList2[iene2]
                        dict2 = getFluorescence(pseudomatrix, energy,
                                                attenuators = workattenuators,
                                                alphain =  -90.,
                                                alphaout = alphaout,
                                                elementsList = newelementsList,
                                                cascade  = cascade,
                                                detector = workdetector,
                                                userElementDict = userElementDict)
                        if optimized:
                            #give back with concentration 1
                            #for ele in dict.keys():
                            for ele in dict2.keys():
                                dict2[ele]['weight'] = weightList3[iene2] * 1.0
                                dict2[ele]['mass fraction'] = eleDict[ele] * 1.0
                        else:
                            #already corrected for concentration
                            #for ele in dict.keys():
                            for ele in dict2.keys():
                                dict2[ele]['weight'] = weightList3[iene2] * eleDict[ele]
                                dict2[ele]['mass fraction'] = eleDict[ele] * 1.0
                        dictList.append(dict2)
        if optimized:
            pass
        else:
            newelementsList = [[getz(x),x] for x in newelementsList]
        if fulloutput:
            result.append(_combineMatrixFluorescenceDict(dictList, newelementsList))
        dictListList += dictList
    #print "total elapsed = ",time.time() - t0
    if fulloutput:
        if optimized:
            return [_combineMatrixFluorescenceDict(dictListList, elementsList)] + result
        else:
            newelementsList = [[getz(x),x] for x in (elementsListFinal + forcedElementsList)]
            return [_combineMatrixFluorescenceDict(dictListList, newelementsList)] +result
    else:
        if optimized:
            return _combineMatrixFluorescenceDict(dictListList, elementsList)
        else:
            newelementsList = [[getz(x),x] for x in (elementsListFinal + forcedElementsList)]
            return _combineMatrixFluorescenceDict(dictListList, newelementsList)

def getMatrixFluorescence(matrix, energyList0, weightList0=None,flagList0=None,
                          fulloutput=None, beamfilters=None,
                          multilayer=None,**kw):
    """
    multilayer is an attenuator like list used when matrix is defined as 
    ['multilayer', density, thickness] This beheaviour is specific to the
    mca fit routines.
    Warning this routine normalize the different weights prior to take into account
    the beam filters and multilayer. After does not do it.
    """
    #print "matrix = ",matrix
    #print "energylist0 = ",energyList0
    #print "weightlist0 = ",weightList0
    #print "flaglist0 =",flagList0
    if beamfilters is None:beamfilters = []
    if len(beamfilters):
        if type(beamfilters[0]) != types.ListType:
            beamfilters=[beamfilters]
    if multilayer is None:multilayer = []
    if len(multilayer):
        if type(multilayer[0]) != types.ListType:
            multilayer=[multilayer]

    if fulloutput  is None:fulloutput  = 0
    if type(energyList0) != types.ListType:
        energyList = [energyList0]
    else:
        energyList = energyList0
    energyList = Numeric.array(energyList)
    if weightList0 is not None:
        if type(weightList0) != types.ListType:
            weightList = [weightList0]
        else:
            weightList = weightList0
        weightList = Numeric.array(weightList)
    else:
        weightList = Numeric.ones(len(energyList)).astype(Numeric.Float)
    if flagList0 is not None:
        if type(flagList0) != types.ListType:
            flagList = [flagList0]
        else:
            flagList = flagList0
        flagList   = Numeric.array(flagList)
    else:
        flagList = Numeric.ones(len(energyList)).astype(Numeric.Float)
    #check lengths to be sure
    #to be done
    alphain  = kw.get('alphain',None)
    alphaout = kw.get('alphain',None)
    if alphain  is None: alphain  = 45.0
    if alphaout is None: alphaout = 45.0
    sinAlphaIn   = Numeric.sin(alphain * (Numeric.pi)/180.)
    sinAlphaOut  = Numeric.sin(alphaout * (Numeric.pi)/180.)

    if kw.has_key('elementsList'):elementsList = kw['elementsList']
    else:elementsList = None
    if elementsList is None:
        #get material elements and concentrations
        if matrix[0].upper() != "MULTILAYER":
            eleDict = getMaterialMassFractions([matrix[0]], [1.0])
            if eleDict == {}: return {}    
            #sort the elements according to atomic number (not needed because the output will be a dictionnary)
            keys = eleDict.keys()
            elementsList = [[getz(x),x] for x in keys]
            elementsList.sort()
        else:
            elementsList = []
            for pseudomatrix in multilayer:
                print "pseudomatrix[0] = ",pseudomatrix[0]
                eleDict = getMaterialMassFractions([pseudomatrix[0] * 1], [1.0])
                if eleDict == {}:
                    raise "ValueError", "Invalid layer material %s" % pseudomatrix[0]
                #sort the elements according to atomic number (not needed because the output will be a dictionnary)
                keys = eleDict.keys()
                elementsList0 = [[getz(x),x] for x in keys]
                elementsList0.sort()
                for item in elementsList0:
                    if item not in elementsList:
                        elementsList.append(item)
            elementsList.sort()
    else:
        if (type(elementsList) != types.ListType) and (type(elementsList) != types.TupleType):
            elementsList  = [elementsList]
        #print "elementsList = ",elementsList
        if len(elementsList):
            if type(elementsList[0]) != types.ListType:
                elementsList = [[getz(x),x] for x in elementsList]
                elementsList.sort()
                eleDict = {}
                for z, ele in elementsList:
                    eleDict[ele] = 1.0
            else:
                eleDict = {}
                for z, ele, peakrays in elementsList:
                    eleDict[ele] = 1.0
        else:
            raise "ValueError", "Empty elements list"

    i0 = Numeric.nonzero(flagList>0)
    weightList = Numeric.take(weightList, i0).astype(Numeric.Float)
    energyList = Numeric.take(energyList, i0).astype(Numeric.Float)
    flagList   = Numeric.take(flagList, i0).astype(Numeric.Float)

    #normalize selected weights
    total = sum(weightList)
    for beamfilter in beamfilters:
        formula   = beamfilter[0]
        thickness = beamfilter[1] * beamfilter[2]
        coeffs   =  thickness * Numeric.array(getMaterialMassAttenuationCoefficients(formula,1.0,energyList)['total'])
        try:
            trans = Numeric.exp(-coeffs)
        except OverflowError:
            #deal with underflows reported as overflows
            trans = Numeric.zeros(len(energyList), Numeric.Float)
            for i in range(len(energyList)):
                coef = coeffs[i]
                if coef < 0.0:
                    raise "ValueError","Positive exponent in attenuators transmission term"
                else:
                    try:
                        trans[i] = Numeric.exp(-coef)
                    except OverflowError:
                        #if we are here we know it is not an overflow and trans[i] has the proper value
                        pass
        weightList = weightList * trans

    if total <= 0.0:raise "ValueError","Sum of weights lower or equal to 0"
    dictList =[]
    if matrix[0].upper() != "MULTILAYER":
        for i in range(len(energyList)):
            dict = getFluorescence(matrix, energyList[i],**kw)
            dict['weight'] = weightList[i]/total
            dict['energy'] = energyList[i]
            dictList.append(dict)
        if fulloutput:
            return [dictList]
        else:
            #this is the way the fit expects it
            if len(elementsList[0]) == 3:
               elementsList = [[x[0], x[1]] for x in elementsList]
            return _combineMatrixFluorescenceDict(dictList, elementsList)
    else:
        origkw ={}
        origkw.update(kw)
        result = []
        if origkw.has_key('attenuators'):
            attenuators = origkw['attenuators'] * 1
        else:
            attenuators = []
        for ilayer in range(len(multilayer)):  
            dictList = []
            pseudomatrix = multilayer[ilayer] * 1
            if ilayer > 0:
                attenuators.append(multilayer[ilayer-1] * 1)
                attenuators[-1][2] =attenuators[-1][2]/sinAlphaOut
                kw['attenuators'] = attenuators
            weightList0 = weightList * 1.0
            for beamfilter in multilayer[0:ilayer]:
                formula   = beamfilter[0]
                thickness = beamfilter[1] * beamfilter[2]/sinAlphaIn
                coeffs   =  thickness * \
                            Numeric.array(getMaterialMassAttenuationCoefficients(formula,1.0,energyList)['total'])
                try:
                    trans = Numeric.exp(-coeffs)
                except OverflowError:
                    #deal with underflows reported as overflows
                    trans = Numeric.zeros(len(energyList), Numeric.Float)
                    for i in range(len(energyList)):
                        coef = coeffs[i]
                        if coef < 0.0:
                            raise "ValueError","Positive exponent in attenuators transmission term"
                        else:
                            try:
                                trans[i] = Numeric.exp(-coef)
                            except OverflowError:
                                #if we are here we know it is not an overflow and trans[i] has the proper value
                                pass
                weightList0 = weightList0 * trans
            for i in range(len(energyList)):
                dict = getFluorescence(pseudomatrix, 
                                       energyList[i],
                                           **kw)
                filterWeight = 1.0
                dict['weight'] = (weightList0[i])/total
                dict['energy'] = energyList[i]
                dictList.append(dict)
            if fulloutput:
                result.append(dictList)
            else:
                result += dictList
        if fulloutput:
            return result
        else:
            #this is the way the fit expects it
            if len(elementsList[0]) == 3:
               elementsList = [[x[0], x[1]] for x in elementsList]
            return _combineMatrixFluorescenceDict(result, elementsList)

def _combineMatrixFluorescenceDict(dictList, elementsList0):
    finalDict = {} 
    elementsList = [[x[0], x[1]] for x in elementsList0]
    for z,ele in elementsList:
        #print ele
        finalDict[ele] = {}
        finalDict[ele]['rates'] = {}
        finalDict[ele]['mass fraction'] = {}
        finalDict[ele]['rays']=[]
        for dict in dictList:
            if not dict.has_key(ele):continue
            if not len(dict[ele]['rays']):continue
            finalDict[ele]['mass fraction'] = dict[ele]['mass fraction'] * 1.0
            for key in dict[ele]['rates'].keys():
                if key not in finalDict[ele]['rates']:
                    if not dict[ele].has_key('weight'):dict[ele]['weight']=dict['weight'] * 1.0
                    finalDict[ele]['rates'][key] = dict[ele]['rates'][key] *  dict[ele]['weight']
                else:
                    if not dict[ele].has_key('weight'):dict[ele]['weight']=dict['weight'] * 1.0
                    finalDict[ele]['rates'][key] += dict[ele]['rates'][key] *  dict[ele]['weight']
            for transitions0 in dict[ele]['rays']:
                #try to avoid creation of new references
                transitions = transitions0 * 1
                if transitions not in dict[ele]['rates'].keys(): continue
                if transitions not in finalDict[ele]['rays']:
                    finalDict[ele]['rays'].append(transitions)
                    finalDict[ele][transitions] = []
                if not (dict[ele]['weight'] > 0.0): continue
                else: w = dict[ele]['weight']
                for transition0 in dict[ele][transitions]:
                    transition = transition0 * 1
                    #print ele,"transition = ",transition
                    if not finalDict[ele].has_key(transition):
                        finalDict[ele][transition] = {'rate':0.0,
                                   'energy':dict[ele][transition]['energy'] * 1}
                    if transition not in finalDict[ele][transitions]:
                        finalDict[ele][transitions].append(transition)
                    if transition not in finalDict[ele].keys():
                        finalDict[ele][transition] = {'rate':0.0}
                    if dict[ele].has_key(transition):
                      if finalDict[ele].has_key(transition):
                        finalDict[ele][transition]['rate'] += w * dict[ele][transition]['rate']
                      else:
                        finalDict[ele][transition] = {}
                        finalDict[ele][transition]['rate'] = w * dict[ele][transition]['rate']
                    else:
                        print dict[ele][transitions]
                        print transition
                        print "is this an error?"
                        sys.exit(0)
    return finalDict

def getScattering(matrix, energy, attenuators = None, alphain = None, alphaout = None,
                                                elementsList = None, cascade=None, 
                                                detector=None):
    if alphain  is None: alphain  = 45.0
    if alphaout is None: alphaout = 45.0
    sinAlphaIn   = Numeric.sin(alphain * (Numeric.pi)/180.)
    sinAlphaOut  = Numeric.sin(alphaout * (Numeric.pi)/180.)
    if attenuators is None: attenuators = []
    if len(attenuators):
        if type(attenuators[0]) != types.ListType:
            attenuators=[attenuators]
    if detector is not None:
        if type(detector) != types.ListType:
            raise "TypeError", \
                  "Detector must be a list as [material, density, thickness]"
        elif len(detector) != 3:
            raise "ValueError", \
                  "Detector must have the form [material, density, thickness]"

    if energy is None: raise "ValueError", "Invalid Energy"
    
    if elementsList is None:
        #get material elements and concentrations
        eleDict = getMaterialMassFractions([matrix[0]], [1.0])
        if eleDict == {}: return {}    
        #sort the elements according to atomic number (not needed because the output will be a dictionnary)
        keys = eleDict.keys()
        elementsList = [[getz(x),x] for x in keys]
        elementsList.sort()
    else:
        if (type(elementsList) != types.ListType) and (type(elementsList) != types.TupleType):
            elementsList  = [elementsList] 
        elementsList = [[getz(x),x] for x in elementsList]
        elementsList.sort()
        eleDict = {}
        for z, ele in elementsList:
            eleDict[ele] = 1.0    

    if energy <= 0.10: raise "ValueError", "Invalid Energy %.5g keV" % energy
    
    #do the job
    outputDict = {}
    shelllist = ['Coherent', 'Compton']
    for z,ele in elementsList:
        outputDict[ele] ={}
        outputDict[ele]['mass fraction'] = eleDict[ele]
        outputDict[ele]['rates'] = {}
        outputDict[ele]['rays'] = ['Coherent','Compton']
        for rays in outputDict[ele]['rays']:
            theta = alphain + alphaout
            outputDict[ele][rays] = {}
            if rays == 'Coherent':
                outputDict[ele][rays]['energy'] = energy
                rates=[getElementCoherentDifferentialCrossSection(ele, theta, energy)]
            else:
                outputDict[ele][rays]['energy'] = IncoherentScattering.getComptonScatteringEnergy(energy,
                                                            theta)
                rates=[getElementComptonDifferentialCrossSection(ele, theta, energy)]
            ene = outputDict[ele][rays]['energy']
            energies =[ene]

            #I do not know if to include this loop in the previous one (because rates are 0.0 sometimes)    
            #attenuators
            for attenuator in attenuators:
                formula   = attenuator[0]
                thickness = attenuator[1] * attenuator[2]
                coeffs   =  thickness * Numeric.array(getMaterialMassAttenuationCoefficients(formula,1.0,energies)['total'])
                try:
                    trans = Numeric.exp(-coeffs)
                except OverflowError:
                    #deal with underflows reported as overflows
                    trans = Numeric.zeros(len(energies), Numeric.Float)
                    for i in range(len(energies)):
                        coef = coeffs[i]
                        if coef < 0.0:
                            raise "ValueError","Positive exponent in attenuators transmission term"
                        else:
                            try:
                                trans[i] = Numeric.exp(-coef)
                            except OverflowError:
                                #if we are here we know it is not an overflow and trans[i] has the proper value
                                pass
                for i in range(len(rates)):
                    rates[i] *= trans[i]
            
            #detector term
            if detector is not None:
                formula   = detector[0]
                thickness = detector[1] * detector[2]
                coeffs   =  thickness * Numeric.array(getMaterialMassAttenuationCoefficients(formula,1.0,energies)['total'])
                try:
                    trans = (1.0 - Numeric.exp(-coeffs))
                except OverflowError:
                    #deal with underflows reported as overflows
                    trans = Numeric.ones(len(rates), Numeric.Float) 
                    for i in range(len(rates)):
                        coef = coeffs[i]
                        if coef < 0.0:
                            raise "ValueError","Positive exponent in attenuators transmission term"
                        else:
                            try:
                                trans[i] = 1.0 - Numeric.exp(-coef)
                            except OverflowError:
                                #if we are here we know it is not an overflow and trans[i] has the proper value
                                pass
                for i in range(len(rates)):
                    rates[i] *= trans[i]
            #matrix term
            formula   = matrix[0]
            thickness = matrix[1] * matrix[2]
            energies += [energy]
            allcoeffs   =  getMaterialMassAttenuationCoefficients(formula,1.0,energies)
            mutotal  = allcoeffs['total']
            del energies[-1]
            i = 0
            if 1:
                #thick target term
                trans = outputDict[ele]['mass fraction'] * 1.0/(mutotal[-1] + mutotal[i] * (sinAlphaIn/sinAlphaOut))
                #correction term
                if thickness > 0.0:
                    if abs(sinAlphaIn) > 0.0:
                        try:
                            expterm = Numeric.exp(-((mutotal[-1]/sinAlphaIn) +(mutotal[i]/sinAlphaOut)) * thickness)
                        except OverflowError:
                            if -((mutotal[-1]/sinAlphaIn) +(mutotal[i]/sinAlphaOut)) * thickness > 0.0:
                                raise "ValueError","Positive exponent in transmission term"
                            expterm = 0.0
                        trans *= (1.0 -  expterm)
                #if ele == 'Pb':
                #    oldRatio.append(newpeaks[i][0])
                #    print "energy = %.3f ratio=%.5f transmission = %.5g final=%.5g" % (newpeaks[i][1], newpeaks[i][0],trans,trans * newpeaks[i][0])
                rates[i] *=  trans
                outputDict[ele][rays]['rate'] = rates[i]
            outputDict[ele]['rates'][rays] = sum(rates)
            #outputDict[ele][rays]= Element[ele]['rays'] * 1
    return outputDict 

def getFluorescence(matrix, energy, attenuators = None, alphain = None, alphaout = None,
                                                elementsList = None, cascade=None, 
                                                detector=None,
                                                userElementDict=None):
    """
    getFluorescence(matrixlist, energy, attenuators = None, alphain = None, alphaout = None,
                            elementsList = None, cascade=None, detector=None)
    matrixlist is a list of the form [material, density, thickness]
    energy is the incident beam energy
    attenuators is a list of the form [[material1, density1, thickness1],....]
    alphain  is the incoming beam angle with sample surface
    alphaout is the outgoing beam angle with sample surface
    if a given elements list is given, the fluorescence rate will be calculated for ONLY 
    for those elements without taking into account if they are present in the matrix and 
    considering a mass fraction of 1 to all of them. This should allow a program to fit
    directly concentrations.
    cascade is a flag to consider vacancy propagation (it is a crude approximation)
    detector is just one attenuator more but treated as (1 - Transmission)
             [material, density, thickness]
    
    These formulae are strictly valid only for parallel beams.
    Needs to be corrected for detector efficiency (at least solid angle) and incoming intensity.
    Secondary transitions are neglected.
    """
    if alphain  is None: alphain  = 45.0
    if alphaout is None: alphaout = 45.0
    if userElementDict is None:userElementDict = {}
    bottomExcitation = False
    if   (alphain < 0.0) and (alphaout < 0.0):
        #it is the same
        sinAlphaIn   = Numeric.sin(-alphain  * (Numeric.pi)/180.)
        sinAlphaOut  = Numeric.sin(-alphaout * (Numeric.pi)/180.)
    elif (alphain < 0.0) and (alphaout > 0.0):
        #bottom excitation
        #print "bottom excitation case"
        bottomExcitation = True
        sinAlphaIn   = Numeric.sin(-alphain * (Numeric.pi)/180.)
        sinAlphaOut  = Numeric.sin(alphaout * (Numeric.pi)/180.)
    else:
        sinAlphaIn   = Numeric.sin(alphain * (Numeric.pi)/180.)
        sinAlphaOut  = Numeric.sin(alphaout * (Numeric.pi)/180.)
    if cascade is None:cascade=False
    if attenuators is None: attenuators = []
    if len(attenuators):
        if type(attenuators[0]) != types.ListType:
            attenuators=[attenuators]
    if detector is not None:
        if type(detector) != types.ListType:
            raise "TypeError", \
                  "Detector must be a list as [material, density, thickness]"
        elif len(detector) != 3:
            raise "ValueError", \
                  "Detector must have the form [material, density, thickness]"

    if energy is None: raise "ValueError", "Invalid Energy"
    
    elementsRays = None
    if elementsList is None:
        #get material elements and concentrations
        eleDict = getMaterialMassFractions([matrix[0]], [1.0])
        if eleDict == {}: return {}    
        #sort the elements according to atomic number 
        #(not needed because the output will be a dictionnary)
        keys = eleDict.keys()
        elementsList = [[getz(x),x] for x in keys]
        elementsList.sort()
    else:
        if (type(elementsList) != types.ListType) and\
           (type(elementsList) != types.TupleType):
            elementsList  = [elementsList]
        if len(elementsList[0]) == 3:
            raysforloopindex = 0
            elementsList.sort()
            elementsRays = [x[2] for x in elementsList]
            elementsList = [[x[0],x[1]] for x in elementsList]
        else:
            elementsList = [[getz(x),x] for x in elementsList]
            elementsList.sort()
        eleDict = {}
        for z, ele in elementsList:
            eleDict[ele] = 1.0    

    if energy <= 0.10: raise "ValueError", "Invalid Energy %.5g keV" % energy
    
    #do the job
    outputDict = {}
    shelllist = ['K', 'L1', 'L2', 'L3','M1', 'M2', 'M3', 'M4', 'M5']
    for z,ele in elementsList:
        #use own unfiltered dictionnary
        if userElementDict.has_key(ele):
            elementDict = userElementDict[ele]
        else:
            elementDict = _getUnfilteredElementDict(ele, energy)
        if not outputDict.has_key(ele): outputDict[ele] ={}
        outputDict[ele]['mass fraction'] = eleDict[ele]
        if not outputDict[ele].has_key('rates'):outputDict[ele]['rates'] = {}
        #get the fluorescence term for all shells
        fluoWeights = _getFluorescenceWeights(ele, energy, normalize = False,
                                                             cascade=cascade)
        outputDict[ele]['rays'] = elementDict['rays'] * 1
        
        if elementsRays is None:
            raysforloop = elementDict['rays']
        else:
            if type(elementsRays[raysforloopindex]) != types.ListType:
                raysforloop = [elementsRays[raysforloopindex] + " xrays"]
            else:
                raysforloop = []
                for item in elementsRays[raysforloopindex]:
                    raysforloop.append(item + " xrays ")
            raysforloopindex +=1
        for rays in raysforloop:
            if rays not in elementDict['rays']:continue
            outputDict[ele][rays] = []
            rates    = []
            energies = []
            transitions = elementDict[rays]
            for transition in transitions:
                outputDict[ele][rays] += [transition]
                outputDict[ele][transition]={}
                outputDict[ele][transition]['rate'] = 0.0
                if transition[0] == "K":
                    rates.append(fluoWeights[0] *  elementDict[transition]['rate'])              
                else:
                    rates.append(fluoWeights[shelllist.index(transition[0:2])] * elementDict[transition]['rate'])
                ene = elementDict[transition]['energy']
                energies += [ene]
                outputDict[ele][transition]['energy'] = ene
                
            #I do not know if to include this loop in the previous one (because rates are 0.0 sometimes)    
            #attenuators
            coeffs = Numeric.zeros(len(energies), Numeric.Float)
            for attenuator in attenuators:
                formula   = attenuator[0]
                thickness = attenuator[1] * attenuator[2]
                coeffs +=  thickness * Numeric.array(getMaterialMassAttenuationCoefficients(formula,1.0,energies)['total'])
            try:
                trans = Numeric.exp(-coeffs)
            except OverflowError:
                for coef in coeffs:
                    if coef < 0.0:
                        raise "ValueError","Positive exponent in attenuators transmission term"    
                trans = 0.0 * coeffs            
            for i in range(len(rates)):
                rates[i] *= trans[i]
            #detector term
            if detector is not None:
                formula   = detector[0]
                thickness = detector[1] * detector[2]
                coeffs   =  thickness * Numeric.array(getMaterialMassAttenuationCoefficients(formula,1.0,energies)['total'])
                try:
                    trans = (1.0 - Numeric.exp(-coeffs))
                except OverflowError:
                    #deal with underflows reported as overflows
                    trans = Numeric.ones(len(rates), Numeric.Float) 
                    for i in range(len(rates)):
                        coef = coeffs[i]
                        if coef < 0.0:
                            raise "ValueError","Positive exponent in attenuators transmission term"
                        else:
                            try:
                                trans[i] = 1.0 - Numeric.exp(-coef)
                            except OverflowError:
                                #if we are here we know it is not an overflow and trans[i] has the proper value
                                pass
                for i in range(len(rates)):
                    rates[i] *= trans[i]
            #matrix term
            formula   = matrix[0]
            thickness = matrix[1] * matrix[2]
            energies += [energy]
            allcoeffs   =  getMaterialMassAttenuationCoefficients(formula,1.0,energies)
            mutotal  = allcoeffs['total']
            #muphoto  = allcoeffs['photo']
            muphoto  = getMaterialMassAttenuationCoefficients(ele,1.0,energy)['photo']
            del energies[-1]
            i = 0            
            for transition in transitions:
                #thick target term
                if rates[i] <= 0.0:trans=0.0
                else:
                    if bottomExcitation:
                        denominator = (mutotal[-1] - mutotal[i] * (sinAlphaIn/sinAlphaOut))
                        if denominator == 0.0:
                            trans = thickness/sinAlphaIn
                            trans = -outputDict[ele]['mass fraction'] *\
                                     muphoto[-1] * trans *\
                                     Numeric.exp(-trans*mutotal[-1])
                        else:
                            trans = -outputDict[ele]['mass fraction'] *\
                                     muphoto[-1]/denominator
                            #correction term
                            if thickness > 0.0:
                                try:
                                    expterm = Numeric.exp(-(mutotal[-1]/sinAlphaIn) * thickness) -\
                                              Numeric.exp(-(mutotal[i]/sinAlphaOut) * thickness)
                                except OverflowError:
                                    #print "overflow"
                                    if ((-(mutotal[-1]/sinAlphaIn) * thickness) > 0.0) or\
                                       ((-(mutotal[i]/sinAlphaOut) * thickness) > 0.0):
                                        raise "ValueError","Positive exponent in transmission term"
                                    expterm = 0.0
                                trans *= expterm
                            else:
                                raise "ValueError","Incorrect target density and/or thickness"
                        if trans < 0.0:
                            print "trans lower than 0.0. Reset to 0.0"
                            trans = 0.0

                    else:
                        trans = outputDict[ele]['mass fraction'] *\
                                 muphoto[-1]/(mutotal[-1] + mutotal[i] * (sinAlphaIn/sinAlphaOut))

                        #correction term
                        if thickness > 0.0:
                            if abs(sinAlphaIn) > 0.0:
                                try:
                                    expterm = Numeric.exp(-((mutotal[-1]/sinAlphaIn) +(mutotal[i]/sinAlphaOut)) * thickness)
                                except OverflowError:
                                    #print "overflow"
                                    if -((mutotal[-1]/sinAlphaIn) +(mutotal[i]/sinAlphaOut)) * thickness > 0.0:
                                        raise "ValueError","Positive exponent in transmission term"
                                    expterm = 0.0
                                trans *= (1.0 -  expterm)
                    #if ele == 'Pb':
                    #    oldRatio.append(newpeaks[i][0])
                    #    print "energy = %.3f ratio=%.5f transmission = %.5g final=%.5g" % (newpeaks[i][1], newpeaks[i][0],trans,trans * newpeaks[i][0])
                    rates[i] *=  trans
                outputDict[ele][transition]['rate'] = rates[i]
                i += 1
            outputDict[ele]['rates'][rays] = sum(rates)
            #outputDict[ele][rays]= Element[ele]['rays'] * 1
    return outputDict 


def getLWeights(ele,energy=None, normalize = None, shellist = None):
    if normalize is None:normalize = True
    if shellist is None: shellist  = ['L1', 'L2', 'L3']
    if type(ele) == type(" "):
        pass
    else:
        ele = getsymbol(int(ele))
    if energy is None:
        #Use the L shell jumps
        w = getLJumpWeight(ele,excitedshells=[1.0,1.0,1.0])
        #weights due to Coster Kronig transitions and fluorescence yields
        ck= LShell.getCosterKronig(ele)
        w[0] *=  1.0
        w[1] *= (1.0 + ck['f12'] * w[0])
        w[2] *= (1.0 + ck['f13'] * w[0] + ck['f23'] * w[1])
        omega = [ getomegal1(ele), getomegal2(ele), getomegal3(ele)]
        for i in range(len(w)):
            w[i] *= omega[i]
    else:
        #Take into account the cascade as in the getFluorescence method
        #The PyMCA fit was already using that when there was a matrix but
        #it was not shown in the Elements Info window.
        allweights = _getFluorescenceWeights(ele, energy, normalize = False, cascade = True)
        w   = allweights[1:4]
    if normalize:
        cum = sum(w)
        if cum > 0.0:
            for i in range(len(w)):
                w[i] /= cum
    return w

def getMWeights(ele,energy=None, normalize = None, shellist = None):
    if normalize is None:normalize = True
    if shellist is None: shellist  = ['M1', 'M2', 'M3', 'M4', 'M5']
    if type(ele) == type(" "):
        pass
    else:
        ele = getsymbol(int(ele))
    if energy is None:
        w = getMJumpWeight(ele,excitedshells=[1.0,1.0,1.0,1.0,1.0])
        #weights due to Coster Kronig transitions and fluorescence yields
        ck= MShell.getCosterKronig(ele)
        w[0] *=  1.0
        w[1] *= (1.0 + ck['f12'] * w[0])
        w[2] *= (1.0 + ck['f13'] * w[0] + ck['f23'] * w[1])
        w[3] *= (1.0 + ck['f14'] * w[0] + ck['f24'] * w[1] + ck['f34'] * w[2])
        w[4] *= (1.0 + ck['f15'] * w[0] + ck['f25'] * w[1] + ck['f35'] * w[2] + ck['f45'] * w[3])
        omega = [ getomegam1(ele), getomegam2(ele), getomegam3(ele), getomegam4(ele), getomegam5(ele)]
        for i in range(len(w)):
            w[i] *= omega[i]
    else:
        #Take into account the cascade as in the getFluorescence method
        #The PyMCA fit was already using that when there was a matrix but
        #it was not shown in the Elements Info window.
        allweights = _getFluorescenceWeights(ele, energy, normalize = False, cascade = True)
        w   = allweights[4:9]
    if normalize:
        cum = sum(w)
        for i in range(len(w)):
            if cum > 0.0:
                w[i] /= cum
    return w


def getxrayenergy(symbol,transition):
    if len(symbol) > 1:
        ele = string.upper(symbol[0])+string.lower(symbol[1])
    else:
        ele = string.upper(symbol)
    trans   = string.upper(transition)
    z = getz(ele)
    if z > len(ElementBinding):
        #Give the bindings of the last element
        energies = ElementBinding[-1]
    else:
        energies = ElementBinding[z-1]

    if len(trans) == 2:
        trans=trans[0:2]+'2'
    if trans[0:1] == 'K':
        i=1
        emax = energies[ElementShells.index('K')+1]
    elif trans[0:2] in ElementShells:    
        i=2
        emax = energies[ElementShells.index(trans[0:2])+1]
    else:
        #print transition
        #print "Shell %s not in Element %s Shells" % (trans[0:2], ele)
        return -1
    
    if trans[i:i+2] in ElementShells:
        emin = energies[ElementShells.index(trans[i:i+2])+1]
    else:
        if (z > 80) and (trans[i:i+2] == "Q1"):
            emin = 0.003
        else:
            #print "HERE ",trans[i:i+2],transition,z
            #print "Final shell %s not in Element %s Shells" % (trans[i:i+1], ele)
            return -1

    if emin > emax:
        if z != 13:
            print "Warning, negative energy!"
            print "Please report this message:"
            print "Symbol=",symbol
            print "emin = ",emin
            print "emax = ",emax
            print "z    = ",z
            print "transition = ",transition
            print "the transition will be ignored"
    return emax - emin

def isValidFormula(compound):
    #single element case
    if compound in Element.keys():return True
    try:
        elts= [ w for w in re.split('[0-9]', compound) if w<>'' ]
        nbs= [ int(w) for w in re.split('[a-zA-Z]', compound) if w<>'' ]
    except:
        return False
    if len(elts)==1 and len(nbs)==0:
        if elts in Element.keys():
            return True
        else:
            return False
    if (len(elts)==0 and len(nbs)==0) or (len(elts)<>len(nbs)):return False
    return True

def isValidMaterial(compound):
    if compound in Material.keys():return True
    elif isValidFormula(compound):return True
    else:return False

def getMaterialKey(compound):
    matkeys = Material.keys()
    if compound in matkeys:return compound
    compoundHigh = compound.upper()
    matkeysHigh  = []
    for key in matkeys:
        matkeysHigh.append(key.upper())
    if compoundHigh in matkeysHigh:
        index = matkeysHigh.index(compoundHigh)
        return matkeys[index]
    return None

def getmassattcoef(compound,energy=None):
    """
    Usage: getmassattcoef(element symbol/composite, energy in kev)
	    Computes mass attenuation coefficients for a single element or a compound.
        It gets the info from files generated by XCOM
        If energy is not given, it gives back a dictionary with the form:
            dict['energy']     = [energies]
            dict['coherent']   = [coherent scattering cross section(energies)]
            dict['compton']    = [incoherent scattering cross section(energies)]
            dict['photo']      = [photoelectic effect cross section(energies)]
            dict['pair']       = [pair production cross section(energies)]
            dict['total']      = [total cross section]
            
	    A compound is defined with a string as follow: 
		'C22H10N2O5' means 22 * C, 10 * H, 2 * N, 5 * O
        
		xsection = SUM(xsection(zi)*ni*ai) / SUM(ai*ni)
        
		zi = Z of each element
		ni = number of element zi
		ai = atomic weight of element zi

	    Result in cm2/g
	"""
    #single element case
    if compound in Element.keys():return getelementmassattcoef(compound,energy)
    elts= [ w for w in re.split('[0-9]', compound) if w<>'' ]
    nbs= [ int(w) for w in re.split('[a-zA-Z]', compound) if w<>'' ]
    if len(elts)==1 and len(nbs)==0:
        if elts in Element.keys():
            return getelementmassattcoef(compound,energy)
        else:
            return {}
    if (len(elts)==0 and len(nbs)==0) or (len(elts)<>len(nbs)):return {}

    fraction = [Element[elt]['mass'] *nb for (elt, nb) in zip(elts, nbs) ]
    div      = sum(fraction)
    fraction = [x/div for x in fraction]
    #print "fraction = ",fraction
    dict={}
    dict['energy']   = []
    dict['coherent'] = []
    dict['compton']  = []
    dict['photo']    = []
    dict['pair']     = []
    dict['total']    = []
    eltindex = 0
    if energy is None:
        energy=[]
        for ele in elts:            
            xcom_data = getelementmassattcoef(ele,None)['energy']
            for ene in xcom_data:
                if ene not in energy:
                    energy.append(ene)
        energy.sort()

    for ele in elts:
        xcom_data = getelementmassattcoef(ele,None)
        #now I have to interpolate at the different energies
        if (type(energy) != type([])):
            energy =[energy]
        eneindex = 0
        for ene in energy:
                i0=max(Numeric.nonzero((xcom_data['energy'] <= ene)))
                i1=min(Numeric.nonzero((xcom_data['energy'] >= ene)))
                if (i1 == i0) or (i0>i1):
                    cohe=xcom_data['coherent'][i1]
                    comp=xcom_data['compton'][i1]
                    photo=xcom_data['photo'][i1]
                    pair=xcom_data['pair'][i1]            
                else:
                    A=xcom_data['energy'][i0]
                    B=xcom_data['energy'][i1]
                    c2=(ene-A)/(B-A)
                    c1=(B-ene)/(B-A)

                    cohe= pow(10.0,c2*Numeric.log10(xcom_data['coherent'][i1])+\
                                            c1*Numeric.log10(xcom_data['coherent'][i0]))
                    comp= pow(10.0,c2*Numeric.log10(xcom_data['compton'][i1])+\
                                            c1*Numeric.log10(xcom_data['compton'][i0]))
                    photo=pow(10.0,c2*Numeric.log10(xcom_data['photo'][i1])+\
                                            c1*Numeric.log10(xcom_data['photo'][i0]))
                    if xcom_data['pair'][i1] > 0.0:
                        c2 = c2*Numeric.log10(xcom_data['pair'][i1])
                        if xcom_data['pair'][i0] > 0.0:
                            c1 = c1*Numeric.log10(xcom_data['pair'][i0])
                            pair = pow(10.0,c1+c2)
                        else:
                            pair =0.0
                    else:
                        pair =0.0
                if eltindex == 0:
                    dict['energy'].append(ene)
                    dict['coherent'].append(cohe *fraction[eltindex])
                    dict['compton'].append(comp *fraction[eltindex])
                    dict['photo'].append(photo *fraction[eltindex])
                    dict['pair'].append(pair*fraction[eltindex])
                    dict['total'].append((cohe+comp+photo+pair)*fraction[eltindex])
                else:
                    dict['coherent'][eneindex] += cohe  *fraction[eltindex]
                    dict['compton'] [eneindex] += comp  *fraction[eltindex]
                    dict['photo']   [eneindex] += photo *fraction[eltindex]
                    dict['pair']    [eneindex] += pair  *fraction[eltindex]
                    dict['total']   [eneindex] += (cohe+comp+photo+pair) * fraction[eltindex]
                eneindex += 1
        eltindex += 1    
    return dict                                                          

def __materialInCompoundList(lst):
    for item in lst:
        if item in Material.keys():
            return True
    return False
    
def getMaterialTransmission(compoundList0, fractionList0, energy0 = None,
                            density=None, thickness=None):
    """
    Usage:
    getMaterialTransmission(compoundList, fractionList, energy = None,
                            density=None, thickness=None):
    
    Input
    
    compoundlist - List of elements, compounds or materials
    fractionlist - List of floats indicating the amount of respective material
    energy       - Photon energy (it can be a list)
    density      - Density in g/cm3 (default is 1.0)
    thickness    - Thickness in cm  (default is 1.0)
    
    The product density * thickness has to be in g/cm2
    
    Output
    
    Detailed dictionary. 
    """
    if density   is None: density = 1.0
    if thickness is None: thickness = 1.0
    dict = getMaterialMassAttenuationCoefficients(compoundList0,
                                                 fractionList0, energy0)
    energy = Numeric.array(dict['energy'],Numeric.Float)
    mu     = Numeric.array(dict['total'],Numeric.Float) * density * thickness
    listoutput = True
    if energy0 is not None:
        if type(energy0) != types.ListType:
            listoutput = False    
    if listoutput:
        dict['energy']   = energy.tolist()
        dict['density']  = density
        dict['thickness'] = thickness
        dict['transmission'] = Numeric.exp(-mu).tolist()
    else:
        dict['energy']   = energy
        dict['density']  = density
        dict['thickness'] = thickness
        dict['transmission'] = Numeric.exp(-mu)    
    return dict
    
def getMaterialMassFractions(compoundList0, fractionList0):
    return getMaterialMassAttenuationCoefficients(compoundList0, fractionList0, None, massfractions=True)
    
def getMaterialMassAttenuationCoefficients(compoundList0, fractionList0, energy0 = None,massfractions=False):
    """
    Usage:
        getMaterialMassAttenuationCoefficients(compoundList, fractionList,
                                     energy = None,massfractions=False)
    compoundList - List of compounds into the material
    fractionList - List of masses of each compound
    energy       - Energy at which the values are desired    
    massfractions- Flag to supply mass fractions on output
    """
    if type(compoundList0) != types.ListType:
        compoundList = [compoundList0]
    else:
        compoundList = compoundList0
    if type(fractionList0) == Numeric.ArrayType:
        fractionList = fractionList0.tolist()
    elif type(fractionList0) != types.ListType:
        fractionList = [fractionList0]
    else:
        fractionList = fractionList0
    fractionList = [float(x) for x in fractionList]

    while __materialInCompoundList(compoundList):
        total=sum(fractionList)   
        compoundFractionList = [x/total for x in fractionList]
        #allow materials in compoundList
        newcompound = []
        newfraction = []
        deleteitems = []
        for compound in compoundList:
            if compound in Material.keys():
                if type(Material[compound]['CompoundList']) != types.ListType:
                    Material[compound]['CompoundList']=[Material[compound]['CompoundList']]
                if type(Material[compound]['CompoundFraction']) != types.ListType:
                    Material[compound]['CompoundFraction']=[Material[compound]['CompoundFraction']]
                Material[compound]['CompoundFraction'] = [float(x) for x in Material[compound]['CompoundFraction']]    
                total = sum(Material[compound]['CompoundFraction'])
                j = compoundList.index(compound)
                compoundfraction = fractionList[j]
                i = 0
                for item in Material[compound]['CompoundList']:
                    newcompound.append(item)
                    newfraction.append(Material[compound]['CompoundFraction'][i] * compoundfraction /total)
                    i += 1
                deleteitems.append(j)
        if len(deleteitems):
            deleteitems.reverse()
            for i in deleteitems:
                del compoundList[i]
                del fractionList[i]
            for i in range(len(newcompound)):
                compoundList.append(newcompound[i])    
                fractionList.append(newfraction[i])
    total=sum(fractionList)   
    compoundFractionList = [float(x)/total for x in fractionList]
    materialElements = {}
    energy = energy0 
    if energy0 is not None:
        if   type(energy0) == types.FloatType:
            energy = [energy0]
        elif type(energy0) == types.IntType:
            energy = [1.0 * energy0]
        elif type(energy0) == Numeric.ArrayType:
            energy = energy0.tolist()

    for compound in compoundList:
        elts=[]
        #get energy list
        if compound in Element.keys():
            elts=[compound]
            nbs =[1]
        else:
            elts= [ w for w in re.split('[0-9]', compound) if w<>'' ]
            nbs= [ int(w) for w in re.split('[a-zA-Z]', compound) if w<>'' ]
            if len(elts)==1 and len(nbs)==0:
                elts=[compound]
                nbs =[1]
        if (len(elts)==0 and len(nbs)==0) or (len(elts)<>len(nbs)):
            print "compound %s not understood" % compound
            raise "ValueError", "compound %s not understood" % compound

        #the proportion of the element in that compound times the compound fraction
        fraction = [Element[elt]['mass'] *nb for (elt, nb) in zip(elts, nbs) ]
        div      = sum(fraction)/compoundFractionList[compoundList.index(compound)]
        fraction = [x/div for x in fraction]
        if energy is None:
            #get energy list
            energy = []
            for ele in elts:
                xcom_data = getelementmassattcoef(ele,None)['energy']
                for ene in xcom_data:
                    if ene not in energy:
                        energy.append(ene)
        for ele in elts:
            if ele not in materialElements.keys():
                materialElements[ele]  = fraction[elts.index(ele)]
            else:
                materialElements[ele] += fraction[elts.index(ele)]
    if massfractions == True:
        return materialElements
    if energy0 is None:
        energy.sort()

    #I have the energy grid, the elements and their fractions
    dict={}
    dict['energy']   = []
    dict['coherent'] = []
    dict['compton']  = []
    dict['photo']    = []
    dict['pair']     = []
    dict['total']    = []
    eltindex = 0
    for ele in materialElements.keys():
        if Element[ele].has_key('xcom'):
            xcom_data = Element[ele]['xcom']       
        else:
            xcom_data = getelementmassattcoef(ele,None)
        #now I have to interpolate at the different energies
        if (type(energy) != type([])):
            energy =[energy]
        eneindex = 0
        for ene in energy:
                i0=max(Numeric.nonzero((xcom_data['energy'] <= ene)))
                i1=min(Numeric.nonzero((xcom_data['energy'] >= ene)))
                if (i1 == i0) or (i0>i1):
                    cohe=xcom_data['coherent'][i1]
                    comp=xcom_data['compton'][i1]
                    photo=xcom_data['photo'][i1]
                    pair=xcom_data['pair'][i1]            
                else:
                    A=xcom_data['energy'][i0]
                    B=xcom_data['energy'][i1]
                    c2=(ene-A)/(B-A)
                    c1=(B-ene)/(B-A)
                    cohe= pow(10.0,c2*xcom_data['coherentlog10'][i1]+\
                                   c1*xcom_data['coherentlog10'][i0])
                    comp= pow(10.0,c2*xcom_data['comptonlog10'][i1]+\
                                   c1*xcom_data['comptonlog10'][i0])
                    photo=pow(10.0,c2*xcom_data['photolog10'][i1]+\
                                   c1*xcom_data['photolog10'][i0])
                    if xcom_data['pair'][i1] > 0.0:
                        c2 = c2*Numeric.log10(xcom_data['pair'][i1])
                        if xcom_data['pair'][i0] > 0.0:
                            c1 = c1*Numeric.log10(xcom_data['pair'][i0])
                            pair = pow(10.0,c1+c2)
                        else:
                            pair =0.0
                    else:
                        pair =0.0
                if eltindex == 0:
                    dict['energy'].append(ene)
                    dict['coherent'].append(cohe * materialElements[ele])
                    dict['compton'].append(comp * materialElements[ele])
                    dict['photo'].append(photo * materialElements[ele])
                    dict['pair'].append(pair* materialElements[ele])
                    dict['total'].append((cohe+comp+photo+pair)* materialElements[ele])
                else:
                    dict['coherent'][eneindex] += cohe  * materialElements[ele]
                    dict['compton'] [eneindex] += comp  * materialElements[ele]
                    dict['photo']   [eneindex] += photo * materialElements[ele]
                    dict['pair']    [eneindex] += pair  * materialElements[ele]
                    dict['total']   [eneindex] += (cohe+comp+photo+pair) *  materialElements[ele]
                eneindex += 1
        eltindex += 1    
    return dict

    
def getcandidates(energy,threshold=None,targetrays=None):
    if threshold  is None:threshold = 0.010
    if targetrays is None:targetrays=['K','L1','L2','L3']
    if type(energy) != type([]):energy=[energy]
    if type(targetrays) != type([]):targetrays=[targetrays]
    #K lines
    lines ={}
    index = 0
    for ene in energy:
        lines[index]={'energy':ene,
                      'elements':[]}
        for ele in ElementList:
            for ray in targetrays:
                rays = ray + " xrays"
                if Element[ele].has_key('rays'):
                    for transition in Element[ele][rays]:
                        e = Element[ele][transition]['energy']
                        r = Element[ele][transition]['rate']
                        if abs(ene-e) < threshold:
                            if ele not in lines[index]['elements']:
                                lines[index]['elements'].append(ele) 
                                lines[index][ele]=[]  
                            lines[index][ele].append([transition,e,r])
        index+=1
    return lines


def getElementFormFactor(ele, theta, energy):
    if ele in CoherentScattering.COEFFICIENTS.keys():
        return CoherentScattering.getElementFormFactor(ele, theta, energy)
    else:
        try:
            z = int(ele)
            ele = getsymbol(z)
            return CoherentScattering.getElementFormFactor(ele, theta, energy)
        except:
            raise "ValueError","Unknown element %s" % ele
    

def getElementCoherentDifferentialCrossSection(ele, theta, energy, p1=None):
    #if ele in CoherentScattering.COEFFICIENTS.keys():
    if ele in ElementList:
        value=CoherentScattering.\
            getElementCoherentDifferentialCrossSection(ele, theta, energy, p1)
    else:
        try:
          z = int(ele)
          ele = getsymbol(z)
          value=CoherentScattering.\
            getElementCoherentDifferentialCrossSection(ele, theta, energy, p1)
        except:
          raise "ValueError","Unknown element %s" % ele
    #convert from cm2/atom to cm2/g
    return (value * 6.022142E23)/ Element[ele]['mass']        


def getElementIncoherentScatteringFunction(ele, theta, energy):
    if ele in ElementList:
        value = IncoherentScattering.\
            getElementIncoherentScatteringFunction(ele, theta, energy)
    else:
        try:
          z = int(ele)
          ele = getsymbol(z)
          value = IncoherentScattering.\
                getElementIncoherentScatteringFunction(ele, theta, energy)
        except:
          raise "ValueError","Unknown element %s" % ele
    return value        

def getElementComptonDifferentialCrossSection(ele, theta, energy, p1=None):
    if ele in ElementList:
        value = IncoherentScattering.\
            getElementComptonDifferentialCrossSection(ele, theta, energy, p1)
    else:
        try:
          z = int(ele)
          ele = getsymbol(z)
          value = IncoherentScattering.\
            getElementComptonDifferentialCrossSection(ele, theta, energy, p1)
        except:
          raise "ValueError","Unknown element %s" % ele
    return (value * 6.022142E23)/ Element[ele]['mass']        

def getelementmassattcoef(ele,energy=None):
    """
    Usage: getelementmassattcoef(element symbol, energy in kev)
        It gets the info from files generated by XCOM
        If energy is not given, it gives back a dictionary with the form:
            dict['energy']     = [energies]
            dict['coherent']   = [coherent scattering cross section(energies)]
            dict['compton']    = [incoherent scattering cross section(energies)]
            dict['photo']      = [photoelectic effect cross section(energies)]
            dict['pair']       = [pair production cross section(energies)]
            dict['total']      = [total cross section]
    """
    if 'xcom' not in Element[ele].keys():
        dirmod = os.path.dirname(Scofield1973.__file__) 
        #read xcom file
        #print dirmod+"/"+ele+".mat"
        xcomfile = os.path.join(dirmod,"attdata")
        xcomfile = os.path.join(xcomfile,ele+".mat")
        if os.path.exists(xcomfile):
            f=open(xcomfile)
        else:
            #freeze does bad things with the path ...
            xcomfile = os.path.dirname(dirmod)
            xcomfile = os.path.join(xcomfile,"attdata")
            xcomfile = os.path.join(xcomfile,ele+".mat")
            if os.path.exists(xcomfile):
                f=open(xcomfile)
            else:
                print "Cannot find file ",xcomfile                
        line=f.readline()
        while (string.split(line,'ENERGY')[0] == line):
            line = f.readline()
        Element[ele]['xcom'] = {}
        Element[ele]['xcom']['energy']   =[]
        Element[ele]['xcom']['coherent'] =[]
        Element[ele]['xcom']['compton']  =[]
        Element[ele]['xcom']['photo']  =[]
        Element[ele]['xcom']['pair']     =[]
        Element[ele]['xcom']['total']    =[]
        line = f.readline()
        while (string.split(line,'COHERENT')[0] == line):
            line = string.split(line)
            for value in line:
                Element[ele]['xcom']['energy'].append(string.atof(value)*1000.)   
            line = f.readline()
        Element[ele]['xcom']['energy']=Numeric.array(Element[ele]['xcom']['energy'])
        line = f.readline()
        while (string.split(line,'INCOHERENT')[0] == line):
            line = string.split(line)
            for value in line:
                Element[ele]['xcom']['coherent'].append(string.atof(value))   
            line = f.readline()
        Element[ele]['xcom']['coherent']=Numeric.array(Element[ele]['xcom']['coherent'])
        line = f.readline()
        while (string.split(line,'PHOTO')[0] == line):
            line = string.split(line)
            for value in line:
                Element[ele]['xcom']['compton'].append(string.atof(value))   
            line = f.readline()
        Element[ele]['xcom']['compton']=Numeric.array(Element[ele]['xcom']['compton'])
        line = f.readline()
        while (string.split(line,'PAIR')[0] == line):
            line = string.split(line)
            for value in line:
                Element[ele]['xcom']['photo'].append(string.atof(value))   
            line = f.readline()
        line = f.readline()
        while (string.split(line,'PAIR')[0] == line):
            line = string.split(line)
            for value in line:
                Element[ele]['xcom']['pair'].append(string.atof(value))   
            line = f.readline()
        i = 0
        line = f.readline()
        while (len(line)):
            line = string.split(line)
            for value in line:
                Element[ele]['xcom']['pair'][i] += string.atof(value)   
                i += 1
            line = f.readline()
        if 0:
            #next line gives problems under under windows
            #just try Numeric.argsort([1,1,1,1,1]) under linux and windows to see
            #what I mean
            i1=Numeric.argsort(Element[ele]['xcom']['energy'])
        else:
            set = map(None,Element[ele]['xcom']['energy'],range(len(Element[ele]['xcom']['energy'])))
            set.sort()
            i1=Numeric.array(map(lambda x:x[1],set))
        Element[ele]['xcom']['energy']=Numeric.take(Element[ele]['xcom']['energy'],i1)
        Element[ele]['xcom']['coherent']=Numeric.take(Element[ele]['xcom']['coherent'],i1)
        Element[ele]['xcom']['compton']=Numeric.take(Element[ele]['xcom']['compton'],i1)
        Element[ele]['xcom']['photo']=Numeric.take(Element[ele]['xcom']['photo'],i1)
        Element[ele]['xcom']['pair']=Numeric.take(Element[ele]['xcom']['pair'],i1)
        Element[ele]['xcom']['coherentlog10']=Numeric.log10(Element[ele]['xcom']['coherent'])
        Element[ele]['xcom']['comptonlog10']=Numeric.log10(Element[ele]['xcom']['compton'])
        Element[ele]['xcom']['photolog10']=Numeric.log10(Element[ele]['xcom']['photo'])
        for i in range(0,len(Element[ele]['xcom']['energy'])):
            Element[ele]['xcom']['total'].append(Element[ele]['xcom']['coherent'][i]+\
                                                 Element[ele]['xcom']['compton'] [i]+\
                                                 Element[ele]['xcom']['photo'] [i]+\
                                                 Element[ele]['xcom']['pair'] [i])

    if energy is None:
        return  Element[ele]['xcom']
    dict={}
    dict['energy']   = []
    dict['coherent'] = []
    dict['compton']  = []
    dict['photo']    = []
    dict['pair']     = []
    dict['total']    = []
    if (type(energy) != type([])):
        energy =[energy]
    for ene in energy:
            i0=max(Numeric.nonzero((Element[ele]['xcom']['energy'] <= ene)))
            i1=min(Numeric.nonzero((Element[ele]['xcom']['energy'] >= ene)))
            if i1 <= i0:
                cohe=Element[ele]['xcom']['coherent'][i1]
                comp=Element[ele]['xcom']['compton'][i1]
                photo=Element[ele]['xcom']['photo'][i1]
                pair=Element[ele]['xcom']['pair'][i1]            
            else:
                A=Element[ele]['xcom']['energy'][i0]
                B=Element[ele]['xcom']['energy'][i1]
                c2=(ene-A)/(B-A)
                c1=(B-ene)/(B-A)
                
                cohe= pow(10.0,c2*Numeric.log10(Element[ele]['xcom']['coherent'][i1])+\
                                        c1*Numeric.log10(Element[ele]['xcom']['coherent'][i0]))
                comp= pow(10.0,c2*Numeric.log10(Element[ele]['xcom']['compton'][i1])+\
                                        c1*Numeric.log10(Element[ele]['xcom']['compton'][i0]))
                photo=pow(10.0,c2*Numeric.log10(Element[ele]['xcom']['photo'][i1])+\
                                        c1*Numeric.log10(Element[ele]['xcom']['photo'][i0]))
                if Element[ele]['xcom']['pair'][i1] > 0.0:
                    c2 = c2*Numeric.log10(Element[ele]['xcom']['pair'][i1])
                    if Element[ele]['xcom']['pair'][i0] > 0.0:
                        c1 = c1*Numeric.log10(Element[ele]['xcom']['pair'][i0])
                        pair = pow(10.0,c1+c2)
                    else:
                        pair =0.0
                else:
                    pair =0.0
            dict['energy'].append(ene)
            dict['coherent'].append(cohe)
            dict['compton'].append(comp)
            dict['photo'].append(photo)
            dict['pair'].append(pair)
            dict['total'].append(cohe+comp+photo+pair)    
    return dict                                                          

def getElementLShellRates(symbol,energy=None,photoweights = None):
    """
    getElementLShellRates(symbol,energy=None, photoweights = None)
    gives LShell branching ratios at a given energy
    weights due to photoeffect, fluorescence and Coster-Kronig
    transitions are calculated and used unless photoweights is False,
    in that case weights = [1.0, 1.0, 1.0, 1.0, 1.0] 
    """
    if photoweights is None:photoweights=True
    if photoweights:
        weights = getLWeights(symbol,energy=energy)
    else:
        weights = [1.0, 1.0, 1.0] 
    z = getz(symbol)
    index = z-1
    shellrates = Numeric.arange(len(LShell.ElementLShellTransitions)).astype(Numeric.Float)
    shellrates[0] = z
    shellrates[1] = 0
    n1 = len(LShell.ElementL1ShellTransitions)
    rates = Numeric.array(LShell.ElementL1ShellRates[index]).astype(Numeric.Float)
    shellrates[2:n1] = (rates[2:] / (sum(rates[2:]) + (sum(rates[2:])==0))) * weights[0]
    n2 = n1 + len(LShell.ElementL2ShellTransitions) - 2
    rates = Numeric.array(LShell.ElementL2ShellRates[index]).astype(Numeric.Float)
    shellrates[n1:n2] = (rates[2:] / (sum(rates[2:]) + (sum(rates[2:])==0))) * weights[1]
    n1 = n2
    n2 = n1 + len(LShell.ElementL3ShellTransitions) - 2
    rates = Numeric.array(LShell.ElementL3ShellRates[index]).astype(Numeric.Float)
    shellrates[n1:n2] = (rates[2:] / (sum(rates[2:]) + (sum(rates[2:])==0))) * weights[2]
    return shellrates

def getElementMShellRates(symbol,energy=None, photoweights = None):
    """
    getElementMShellRates(symbol,energy=None, photoweights = None)
    gives MShell branching ratios at a given energy
    weights due to photoeffect, fluorescence and Coster-Kronig
    transitions are calculated and used unless photoweights is False,
    in that case weights = [1.0, 1.0, 1.0, 1.0, 1.0] 
    """
    if photoweights is None:photoweights=True
    if photoweights:
        weights = getMWeights(symbol,energy=energy)
    else:
        weights = [1.0, 1.0, 1.0, 1.0, 1.0] 
    z = getz(symbol)
    index = z-1
    shellrates = Numeric.arange(len(MShell.ElementMShellTransitions)).astype(Numeric.Float)
    shellrates[0] = z
    shellrates[1] = 0
    n1 = len(MShell.ElementM1ShellTransitions)
    rates = Numeric.array(MShell.ElementM1ShellRates[index]).astype(Numeric.Float)
    shellrates[2:n1] = (rates[2:] / (sum(rates[2:]) + (sum(rates[2:])==0))) * weights[0]
    n2 = n1 + len(MShell.ElementM2ShellTransitions) - 2
    rates = Numeric.array(MShell.ElementM2ShellRates[index]).astype(Numeric.Float)
    shellrates[n1:n2] = (rates[2:] / (sum(rates[2:]) + (sum(rates[2:])==0))) * weights[1]
    n1 = n2
    n2 = n1 + len(MShell.ElementM3ShellTransitions) - 2
    rates = Numeric.array(MShell.ElementM3ShellRates[index]).astype(Numeric.Float)
    shellrates[n1:n2] = (rates[2:] / (sum(rates[2:]) + (sum(rates[2:])==0))) * weights[2]
    n1 = n2
    n2 = n1 + len(MShell.ElementM4ShellTransitions) - 2
    rates = Numeric.array(MShell.ElementM4ShellRates[index]).astype(Numeric.Float)
    shellrates[n1:n2] = (rates[2:] / (sum(rates[2:]) + (sum(rates[2:])==0)))* weights[3]
    n1 = n2
    n2 = n1 + len(MShell.ElementM5ShellTransitions) - 2
    rates = Numeric.array(MShell.ElementM5ShellRates[index]).astype(Numeric.Float)
    shellrates[n1:n2] = (rates[2:] / (sum(rates[2:]) + (sum(rates[2:])==0)))* weights[4]
    return shellrates


def _getUnfilteredElementDict(symbol, energy): 
    dict = {}
    if len(symbol) > 1:
        ele = string.upper(symbol[0])+string.lower(symbol[1])
    else:
        ele = string.upper(symbol)
    #fill the dictionnary
    dict['rays']=[]
    z = getz(ele)
    for n in range(len(ElementXrays)):
        rays = ElementXrays[n]
        if   (rays == 'L xrays'):
            shellrates = getElementLShellRates(ele,energy=energy,photoweights=False)
        elif (rays == 'M xrays'):
            shellrates = getElementMShellRates(ele,energy=energy,photoweights=False)
        else:
            shellrates = ElementShellRates[n][z-1]
        shelltransitions = ElementShellTransitions[n]
        dict[rays] = []
        minenergy = 0.300
        for i in range(2,len(shelltransitions)):
                rate = shellrates [i]            
                transition = shelltransitions[i]        
                if n==0:dict[transition] = {}                   
                xenergy = getxrayenergy(ele,transition.replace('*',''))
                if xenergy > minenergy:
                    dict[transition] = {}
                    dict[rays].append(transition)
                    dict[transition]['energy'] = getxrayenergy(ele,transition)
                    dict[transition]['rate']   = rate
                    if rays not in dict['rays']:
                        dict['rays'].append(rays)
    dict['buildparameters']={}
    dict['buildparameters']['energy']    = energy
    dict['buildparameters']['minenergy'] = minenergy
    dict['buildparameters']['minrate']   = 0.0
    return dict    

    
def _updateElementDict(symbol, dict, energy=None, minenergy=0.3990, minrate=0.0010,
                                                     normalize = None, photoweights = None):
    if normalize   is None: normalize   = True
    if photoweights is None: photoweights = True
    if len(symbol) > 1:
        ele = string.upper(symbol[0])+string.lower(symbol[1])
    else:
        ele = string.upper(symbol)
    #reset existing dictionnary
    if dict.has_key('rays'):
        for rays in dict['rays']:
            for transition in dict[rays]:
                #print "transition deleted = ",transition
                del dict[transition]
            #print "rays deleted = ",rays
            del dict[rays]
    #fill the dictionnary
    dict['rays']=[]
    z = getz(ele)
    for n in range(len(ElementXrays)):
        rays = ElementXrays[n]
        if   (rays == 'L xrays'):
            shellrates = getElementLShellRates(ele,energy=energy,photoweights=photoweights)
        elif (rays == 'M xrays'):
            shellrates = getElementMShellRates(ele,energy=energy,photoweights=photoweights)
        else:
            shellrates = ElementShellRates[n][z-1]
        shelltransitions = ElementShellTransitions[n]
        dict[rays] = []
        maxrate = max(shellrates[2:])
        cum     = 0.0
        if maxrate > minrate:
            for i in range(2,len(shelltransitions)):
                rate = shellrates [i]            
                if (rate/maxrate) > minrate:
                    transition = shelltransitions[i]        
                    xenergy = getxrayenergy(ele,transition.replace('*',''))
                    if (xenergy > minenergy) or (n == 0) :
                        dict[transition] = {}
                        dict[rays].append(transition)
                        dict[transition]['energy'] = getxrayenergy(ele,transition)
                        dict[transition]['rate']   = rate
                        cum += rate
                        if rays not in dict['rays']:
                            dict['rays'].append(rays)
            #cum = 1.00
            if normalize:
                if cum > 0.0:   
                    for transition in dict[rays]:
                        dict[transition]['rate'] /= cum
    dict['buildparameters']={}
    dict['buildparameters']['energy']    = energy
    dict['buildparameters']['minenergy'] = minenergy
    dict['buildparameters']['minrate']   = minrate
    
def updateDict(energy=None, minenergy=0.3990, minrate=0.0010, cb=True):
    for ele in ElementList:
        _updateElementDict(ele, Element[ele], energy=energy, minenergy=minenergy, minrate=minrate)
    if cb:
        _updateCallback()    
    return

def _getMaterialDict():
    cDict = ConfigDict.ConfigDict()
    dirmod  = os.path.dirname(Scofield1973.__file__) 
    matdict = os.path.join(dirmod,"attdata")
    matdict = os.path.join(matdict,"MATERIALS.DICT")
    if os.path.exists(matdict):
        cDict.read(matdict)
    else:
        #freeze does bad things with the path ...
        matdict = os.path.dirname(dirmod)
        matdict = os.path.join(matdict,"attdata")
        matdict = os.path.join(matdict,"MATERIALS.DICT")
        if os.path.exists(matdict):
            cDict.read(matdict)
        else:
            print "Cannot find file ",matdict
            return {}
    return cDict
    
class BoundMethodWeakref:
    """Helper class to get a weakref to a bound method"""
    def __init__(self, bound_method, onDelete=None):
        def remove(ref):
            if self.deleteCb is not None:
                self.deleteCb(self)
        
        self.deleteCb = onDelete
        self.func_ref = weakref.ref(bound_method.im_func, remove)
        self.obj_ref = weakref.ref(bound_method.im_self, remove)

    def __call__(self):
        obj = self.obj_ref()
        if obj is not None:
            func = self.func_ref()
            if func is not None:
                return func.__get__(obj)

    def __cmp__( self, other ):
        """Compare with another reference"""
        if not isinstance (other,self.__class__):
            return cmp( self.__class__, type(other) )
        return cmp( self.func_ref, other.func_ref) and cmp( self.obj_ref, other.obj_ref)

_registeredCallbacks=[]

def registerUpdate(callback):
    if not callable(callback): raise TypeError,"It should be a callable method"

    def delCallback(ref):
        try:
            i = _registeredCallbacks.index(ref)
            del _registeredCallbacks[i]
        except:
            pass
          
    if hasattr(callback, 'im_self') and callback.im_self is not None:
        ref = BoundMethodWeakref(callback, delCallback)   
    else:
        # function weakref
        ref = weakref.ref(callback, delCallback)

    if ref not in  _registeredCallbacks:
        _registeredCallbacks.append(ref)
    

def _updateCallback():
    for methodref in _registeredCallbacks:
        method = methodref()
        if method is not None:
            method()  

        
Element={}
for ele in ElementList:
    z = getz(ele)
    Element[ele]={}
    Element[ele]['Z']       = z
    Element[ele]['name']    = ElementsInfo[z-1][4]
    Element[ele]['mass']    = ElementsInfo[z-1][5]
    Element[ele]['density'] = ElementsInfo[z-1][6]/1000.
    Element[ele]['binding'] = {}
    i=0
    for shell in ElementShells:
        i = i + 1
        if z > len(ElementBinding):
            #Give the bindings of the last element
            Element[ele]['binding'][shell] = ElementBinding[-1][i]
        else:
            Element[ele]['binding'][shell] = ElementBinding[z-1][i]
    #fluorescence yields
    Element[ele]['omegak']  = getomegak(ele)
    Element[ele]['omegal1'] = getomegal1(ele)
    Element[ele]['omegal2'] = getomegal2(ele)
    Element[ele]['omegal3'] = getomegal3(ele)
    Element[ele]['omegam1'] = getomegam1(ele)
    Element[ele]['omegam2'] = getomegam2(ele)
    Element[ele]['omegam3'] = getomegam3(ele)
    Element[ele]['omegam4'] = getomegam4(ele)
    Element[ele]['omegam5'] = getomegam5(ele)


    #Coster-Kronig
    Element[ele]['CosterKronig'] = {}
    Element[ele]['CosterKronig']['L'] = getCosterKronig(ele) 
    Element[ele]['CosterKronig']['M'] = MShell.getCosterKronig(ele) 

    #jump ratios

    #xrays
    #Element[ele]['rays']=[]
    #updateElementDict(ele, Element[ele], energy=None, minenergy=0.399, minrate=0.001,cb=False)
Material = _getMaterialDict()

updateDict()


if __name__ == "__main__":
    import sys
    if len(sys.argv) > 1:
        ele = sys.argv[1]
        if ele in Material.keys():
            print "NEW Air=",getMatrixFluorescence([ele,1.0,0.01],[10.,20],[1.,1.0],[1,1])['Ar']['KL3']
            print "OLD 10 =",getFluorescence([ele,1.0,0.01],10.)['Ar']['KL3']
            print "OLD 20 =",getFluorescence([ele,1.0,0.01],20.)['Ar']['KL3']
            sys.exit(0)
        elif ele in Element.keys():
            print "NEW =",getMatrixFluorescence([ele,1.0,0.01],[13.,18],[1.,1.0],[1,1])[ele]['L3M5']
            a = getFluorescence([ele,1.0,0.01],13.)[ele]
            b = getFluorescence([ele,1.0,0.01],18.)[ele]
            transition = 'L3M5'
            print "OLD 1 =",a[transition]
            print "OLD 2 =",b[transition]
            print  0.5 * (a[transition]['rate'] + b[transition]['rate'])
            sys.exit(0)            
        elif ele in Element.keys():
            print "Symbol        = ",getsymbol(getz(ele))
            print "Atomic Number = ",getz(ele)
            print "Name          = ",getname(getz(ele))
            print "K-shell yield = ",Element[ele]['omegak']
            print "L1-shell yield = ",Element[ele]['omegal1']
            print "L2-shell yield = ",Element[ele]['omegal2']
            print "L3-shell yield = ",Element[ele]['omegal3']
            print "M1-shell yield = ",Element[ele]['omegam1']
            print "M2-shell yield = ",Element[ele]['omegam2']
            print "M3-shell yield = ",Element[ele]['omegam3']
            print "M4-shell yield = ",Element[ele]['omegam4']
            print "M5-shell yield = ",Element[ele]['omegam5']
            print "L Coster-Kronig= ",Element[ele]['CosterKronig']['L']
            print "M Coster-Kronig= ",Element[ele]['CosterKronig']['M']
            if len(sys.argv) > 2:
                def testCallback():
                    print "callback called"
                registerUpdate(testCallback)
                e = string.atof(sys.argv[2])
                if 0:
                    _updateElementDict(ele,Element[ele],energy=e)
                else:
                    import time
                    t0=time.time()
                    updateDict(energy=e)
                    print "update took ",time.time() - t0
            for rays in Element[ele]['rays']:
                print rays,":"
                for transition in Element[ele][rays]:
                    print "%s energy = %.5f  rate = %.5f" % (transition,Element[ele][transition]['energy'],
                                                                        Element[ele][transition]['rate'])
            
        if len(sys.argv) > 2:
            print getmassattcoef(ele,string.atof(sys.argv[2]))
            if len(sys.argv) >3:
                print getcandidates(string.atof(sys.argv[2]),threshold=string.atof(sys.argv[3]))
            else:
                print getcandidates(string.atof(sys.argv[2]))
        else:
            print getmassattcoef(ele,[10.,11,12,12.5])
